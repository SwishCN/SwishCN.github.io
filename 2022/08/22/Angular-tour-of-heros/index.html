

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/headphoto.png">
  <link rel="icon" href="/img/headphoto.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Swish">
  <meta name="keywords" content="">
  
  <title>Angular项目-英雄之旅 - Swish&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/androidstudio.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":5},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Swish's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Angular项目-英雄之旅">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-08-22 00:00" pubdate>
        August 22, 2022
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      254
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Angular项目-英雄之旅</h1>
            
            <div class="markdown-body">
              <p><em>英雄之旅</em>应用可以帮助人力资源管理局管理好自己的英雄。该应用具有许多在任何数据驱动的应用中都可能出现的功能。完成后的应用会获取并显示一些英雄列表、编辑所选英雄的详细信息，并在不同的英雄数据视图之间导航。</p>
<h1 id="0-创建项目"><a href="#0-创建项目" class="headerlink" title="0 创建项目"></a>0 创建项目</h1><h2 id="0-1-创建一个初始应用"><a href="#0-1-创建一个初始应用" class="headerlink" title="0.1 创建一个初始应用"></a>0.1 创建一个初始应用</h2><p>运行 CLI 命令 <code>ng new</code>，空间名请使用 <code>angular-tour-of-heroes</code>，如下所示：</p>
<figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">ng <span class="hljs-keyword">new</span> <span class="hljs-type">angular</span>-tour-of-heroes<br></code></pre></div></td></tr></table></figure>

<p>Angular CLI 会安装必要的 Angular <code>npm</code> 包和其它依赖项。这可能需要几分钟。</p>
<p>它还会创建下列工作区和初始项目的文件：</p>
<ul>
<li>新的工作区，其根目录名叫 <code>angular-tour-of-heroes</code>。</li>
<li>一个最初的骨架应用项目，位于 <code>src/app</code> 子目录下。</li>
<li>相关的配置文件。</li>
</ul>
<h2 id="0-2-启动应用服务器"><a href="#0-2-启动应用服务器" class="headerlink" title="0.2 启动应用服务器"></a>0.2 启动应用服务器</h2><p>进入工作区目录，并启动这个应用。</p>
<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> angular-tour-of-heroes<br>ng serve --<span class="hljs-keyword">open</span><br></code></pre></div></td></tr></table></figure>

<p><code>ng serve</code> 命令会构建本应用、启动开发服务器、监听源文件，并且当那些文件发生变化时重新构建本应用。</p>
<p><code>--open</code> 标志会打开浏览器，并访问 <code>http://localhost:4200/</code>。</p>
<h2 id="0-3-Angular组件"><a href="#0-3-Angular组件" class="headerlink" title="0.3 Angular组件"></a>0.3 Angular组件</h2><p>所看到的这个页面就是<em>应用的外壳</em>。这个外壳是被一个名叫 <code>AppComponent</code> 的 Angular 组件控制的。</p>
<p><em>组件</em>是 Angular 应用中的基本构造块。它们在屏幕上显示数据，监听用户输入，并且根据这些输入执行相应的动作。</p>
<h2 id="0-4-修改应用标题"><a href="#0-4-修改应用标题" class="headerlink" title="0.4 修改应用标题"></a>0.4 修改应用标题</h2><p>用 IDE 打开这个项目，并访问 <code>src/app</code> 目录，来对这个起始应用做一些修改。</p>
<p>会在这里看到 <code>AppComponent</code> 壳的三个实现文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>app.component.ts</code></td>
<td>组件的类代码，这是用 TypeScript 写的。</td>
</tr>
<tr>
<td><code>app.component.html</code></td>
<td>组件的模板，这是用 HTML 写的。</td>
</tr>
<tr>
<td><code>app.component.css</code></td>
<td>组件的私有 CSS 样式。</td>
</tr>
</tbody></table>
<h3 id="0-4-1-更改应用标题"><a href="#0-4-1-更改应用标题" class="headerlink" title="0.4.1 更改应用标题"></a>0.4.1 更改应用标题</h3><p>打开组件的类文件 (<code>app.component.ts</code>)，并把 <code>title</code> 属性的值修改为 ‘Tour of Heroes’（英雄之旅）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">title = <span class="hljs-string">&#x27;Tour of Heroes&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>打开组件的模板文件 <code>app.component.html</code> 并清空 Angular CLI 自动生成的默认模板。改为下列 HTML 内容。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>双花括号语法是 Angular 的<em>插值绑定</em>语法。这个插值绑定的意思是把组件的 <code>title</code> 属性的值绑定到 HTML 中的 <code>h1</code> 标记中。</p>
<p>浏览器自动刷新，并且显示出了新的应用标题。</p>
<h3 id="0-4-2-添加应用样式"><a href="#0-4-2-添加应用样式" class="headerlink" title="0.4.2 添加应用样式"></a>0.4.2 添加应用样式</h3><p>大多数应用都会努力让整个应用保持一致的外观。因此，CLI 会生成一个空白的 <code>styles.css</code> 文件。可以把全应用级别的样式放进去。</p>
<p>打开 <code>src/styles.css</code> 并把下列代码添加到此文件中。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* Application-wide Styles */</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#369</span>;<br>  <span class="hljs-attribute">font-family</span>: Arial, Helvetica, sans-serif;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">250%</span>;<br>&#125;<br><span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#444</span>;<br>  <span class="hljs-attribute">font-family</span>: Arial, Helvetica, sans-serif;<br>  <span class="hljs-attribute">font-weight</span>: lighter;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span>, <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>, <span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">font-family</span>: Cambria, Georgia, serif;<br>&#125;<br><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">border</span>: none;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">1rem</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1rem</span>;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">1rem</span>;<br>&#125;<br><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:disabled</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>;<br>  <span class="hljs-attribute">cursor</span>: auto;<br>&#125;<br><br><span class="hljs-comment">/* everywhere else */</span><br>* &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial, Helvetica, sans-serif;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="0-5-小结"><a href="#0-5-小结" class="headerlink" title="0.5 小结"></a>0.5 小结</h2><ul>
<li>使用 Angular CLI 创建了初始的应用结构</li>
<li>学会了使用 Angular 组件来显示数据</li>
<li>使用双花括号插值显示了应用标题</li>
</ul>
<h1 id="1-英雄编辑器"><a href="#1-英雄编辑器" class="headerlink" title="1 英雄编辑器"></a>1 英雄编辑器</h1><p>应用程序现在有了基本的标题。接下来要创建一个新的组件来显示英雄信息并且把这个组件放到应用程序的外壳里去。</p>
<h2 id="1-1-创建英雄列表组件"><a href="#1-1-创建英雄列表组件" class="headerlink" title="1.1 创建英雄列表组件"></a>1.1 创建英雄列表组件</h2><p>使用 Angular CLI 创建一个名为 <code>heroes</code> 的新组件。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> component heroes<br></code></pre></div></td></tr></table></figure>

<p>CLI 创建了一个新的文件夹 <code>src/app/heroes/</code>，并生成了 <code>HeroesComponent</code> 的四个文件。</p>
<p><code>HeroesComponent</code> 的类文件如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./heroes.component.html&#x27;</span>,<br>  styleUrls: [<span class="hljs-string">&#x27;./heroes.component.css&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>  &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>要从 Angular 核心库中导入 <code>Component</code> 符号，并为组件类加上 <code>@Component</code> 装饰器。</p>
<p><code>@Component</code> 是个装饰器函数，用于为该组件指定 Angular 所需的元数据。</p>
<p>CLI 自动生成了三个元数据属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>selector</code></td>
<td>组件的 CSS 元素选择器</td>
</tr>
<tr>
<td><code>templateUrl</code></td>
<td>组件模板文件的位置。</td>
</tr>
<tr>
<td><code>styleUrls</code></td>
<td>组件私有 CSS 样式表文件的位置。</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/CSS/Type_selectors">CSS 元素选择器</a> <code>app-heroes</code> 用来在父组件的模板中匹配 HTML 元素的名称，以识别出该组件。</p>
<p><code>ngOnInit()</code> 是一个<a target="_blank" rel="noopener" href="https://angular.cn/guide/lifecycle-hooks#oninit">生命周期钩子</a>，Angular 在创建完组件后很快就会调用 <code>ngOnInit()</code>。这里是放置初始化逻辑的好地方。</p>
<p>始终要 <code>export</code> 这个组件类，以便在其它地方（比如 <code>AppModule</code>）导入它。</p>
<h3 id="1-1-1-添加hero属性"><a href="#1-1-1-添加hero属性" class="headerlink" title="1.1.1 添加hero属性"></a>1.1.1 添加hero属性</h3><p>往 <code>HeroesComponent</code> 中添加一个 <code>hero</code> 属性，用来表示一个名叫 “Windstorm” 的英雄。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">hero = <span class="hljs-string">&#x27;Windstorm&#x27;</span>;<br></code></pre></div></td></tr></table></figure>



<h3 id="1-1-2-显示英雄"><a href="#1-1-2-显示英雄" class="headerlink" title="1.1.2 显示英雄"></a>1.1.2 显示英雄</h3><p>打开模板文件 <code>heroes.component.html</code>。删除 Angular CLI 自动生成的默认内容，改为到 <code>hero</code> 属性的数据绑定。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;hero&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<h2 id="1-2-显示HeroesComponent视图"><a href="#1-2-显示HeroesComponent视图" class="headerlink" title="1.2 显示HeroesComponent视图"></a>1.2 显示HeroesComponent视图</h2><p>要显示 <code>HeroesComponent</code> 必须把它加到壳组件 <code>AppComponent</code> 的模板中。</p>
<p>别忘了，<code>app-heroes</code> 就是 <code>HeroesComponent</code> 的 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt1#selector">元素选择器</a>。 所以，只要把 <code>&lt;app-heroes&gt;</code> 元素添加到 <code>AppComponent</code> 的模板文件中就可以了，就放在标题下方。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-heroes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-heroes</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>如果 CLI 的 <code>ng serve</code> 命令仍在运行，浏览器就会自动刷新，并且同时显示出应用的标题和英雄的名字。</p>
<h2 id="1-3-创建Hero类"><a href="#1-3-创建Hero类" class="headerlink" title="1.3 创建Hero类"></a>1.3 创建Hero类</h2><p>真实的英雄当然不止一个名字。</p>
<p>在 <code>src/app</code> 文件夹中为 <code>Hero</code> 类创建一个文件，并添加 <code>id</code> 和 <code>name</code> 属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Hero &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>回到 <code>HeroesComponent</code> 类，并且导入这个 <code>Hero</code> 类。</p>
<p>把组件的 <code>hero</code> 属性的类型重构为 <code>Hero</code>。然后以 <code>1</code> 为 <code>id</code>、以 “Windstorm” 为名字初始化它。</p>
<p>修改后的 <code>HeroesComponent</code> 类应该是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./heroes.component.html&#x27;</span>,<br>  styleUrls: [<span class="hljs-string">&#x27;./heroes.component.css&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br>  hero: Hero = &#123;<br>    id: <span class="hljs-number">1</span>,<br>    name: <span class="hljs-string">&#x27;Windstorm&#x27;</span><br>  &#125;;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>  &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>页面显示变得不正常了，因为刚刚把 <code>hero</code> 从字符串改成了对象。</p>
<h2 id="1-4-显示hero对象"><a href="#1-4-显示hero对象" class="headerlink" title="1.4 显示hero对象"></a>1.4 显示hero对象</h2><p>修改模板中的绑定，以显示英雄的名字，并在详情中显示 <code>id</code> 和 <code>name</code>，就像这样：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;hero.name&#125;&#125; Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>id: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>name: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>浏览器自动刷新，并显示这位英雄的信息。</p>
<h2 id="1-5-使用UppercasePipe进行格式化"><a href="#1-5-使用UppercasePipe进行格式化" class="headerlink" title="1.5 使用UppercasePipe进行格式化"></a>1.5 使用UppercasePipe进行格式化</h2><p>把<code>heroes.component.html</code>中的 <code>hero.name</code> 的绑定修改成这样。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;hero.name | uppercase&#125;&#125; Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>浏览器刷新了。现在，英雄的名字显示成了大写字母。</p>
<p>绑定表达式中的 <code>uppercase</code> 位于管道操作符（<code>|</code>）的右边，用来调用内置管道 <code>UppercasePipe</code>。</p>
<p><a target="_blank" rel="noopener" href="https://angular.cn/guide/pipes">管道</a> 是格式化字符串、金额、日期和其它显示数据的好办法。Angular 发布了一些内置管道，而且还可以创建自己的管道。</p>
<h2 id="1-6-编辑英雄名字"><a href="#1-6-编辑英雄名字" class="headerlink" title="1.6 编辑英雄名字"></a>1.6 编辑英雄名字</h2><p>用户应该能在一个 <code>&lt;input&gt;</code> 输入框中编辑英雄的名字。</p>
<p>当用户输入时，这个输入框应该能同时<em>显示</em>和<em>修改</em>英雄的 <code>name</code> 属性。也就是说，数据流从组件类<strong>流出到屏幕</strong>，并且从屏幕<strong>流回到组件类</strong>。</p>
<p>要想让这种数据流动自动化，就要在表单元素 <code>&lt;input&gt;</code> 和组件的 <code>hero.name</code> 属性之间建立双向数据绑定。</p>
<h3 id="1-6-1-双向绑定"><a href="#1-6-1-双向绑定" class="headerlink" title="1.6.1 双向绑定"></a>1.6.1 双向绑定</h3><p>把模板中的英雄详情区重构成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Hero name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;hero.name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><code>[(ngModel)]</code> 是 Angular 的双向数据绑定语法。</p>
<p>这里把 <code>hero.name</code> 属性绑定到了 HTML 的 textbox 元素上，以便数据流可以<strong>双向流动</strong>：从 <code>hero.name</code> 属性流动到 textbox，并且从 textbox 流回到 <code>hero.name</code>。</p>
<h3 id="1-6-2-缺少FormsModule"><a href="#1-6-2-缺少FormsModule" class="headerlink" title="1.6.2 缺少FormsModule"></a>1.6.2 缺少FormsModule</h3><p>注意，当加上 <code>[(ngModel)]</code> 之后这个应用无法工作了。</p>
<p>打开浏览器的开发工具，就会在控制台中看到如下信息：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">Template parse errors:<br>Can<span class="hljs-symbol">&#x27;t</span> bind <span class="hljs-keyword">to</span> <span class="hljs-symbol">&#x27;ngModel</span>&#x27; since it isn<span class="hljs-symbol">&#x27;t</span> a known <span class="hljs-keyword">property</span> <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;input</span>&#x27;.<br></code></pre></div></td></tr></table></figure>

<p>虽然 <code>ngModel</code> 是一个有效的 Angular 指令，不过它在默认情况下是不可用的。</p>
<p>它属于一个可选模块 <code>FormsModule</code>，必须自行添加此模块才能使用该指令。</p>
<h2 id="1-7-AppModule"><a href="#1-7-AppModule" class="headerlink" title="1.7 AppModule"></a>1.7 AppModule</h2><p>Angular 需要知道如何把应用程序的各个部分组合到一起，以及该应用需要哪些其它文件和库。这些信息被称为<em>元数据（metadata）</em>。</p>
<p>有些元数据位于 <code>@Component</code> 装饰器中，会把它加到组件类上。另一些关键性的元数据位于 <a target="_blank" rel="noopener" href="https://angular.cn/guide/ngmodules"><code>@NgModule</code></a> 装饰器中。</p>
<p>最重要的 <code>@NgModule</code> 装饰器位于顶层类 <strong>AppModule</strong> 上。</p>
<p>Angular CLI 在创建项目的时候就在 <code>src/app/app.module.ts</code> 中生成了一个 <code>AppModule</code> 类。这里也就是要添加 <code>FormsModule</code> 的地方。</p>
<h3 id="1-7-1-导入FormsModule"><a href="#1-7-1-导入FormsModule" class="headerlink" title="1.7.1 导入FormsModule"></a>1.7.1 导入FormsModule</h3><p>打开 <code>AppModule</code> (<code>app.module.ts</code>) 并从 <code>@angular/forms</code> 库中导入 <code>FormsModule</code> 符号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; FormsModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/forms&#x27;</span>; <span class="hljs-comment">// &lt;-- NgModel lives here</span><br></code></pre></div></td></tr></table></figure>

<p>然后把 <code>FormsModule</code> 添加到 <code>@NgModule</code> 元数据的 <code>imports</code> 数组中，这里是该应用所需外部模块的列表。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">imports: [<br>  BrowserModule,<br>  FormsModule<br>],<br></code></pre></div></td></tr></table></figure>

<p>刷新浏览器，应用又能正常工作了。可以编辑英雄的名字，并且会看到这个改动立刻体现在这个输入框上方的 <code>&lt;h2&gt;</code> 中。</p>
<h3 id="1-7-2-声明HeroesComponent"><a href="#1-7-2-声明HeroesComponent" class="headerlink" title="1.7.2 声明HeroesComponent"></a>1.7.2 声明HeroesComponent</h3><p>每个组件都必须声明在（<em>且只能声明在</em>）一个 <a target="_blank" rel="noopener" href="https://angular.cn/guide/ngmodules">NgModule</a> 中。</p>
<p>没有声明过 <code>HeroesComponent</code>，可为什么本应用却正常呢？</p>
<p>这是因为 Angular CLI 在生成 <code>HeroesComponent</code> 组件的时候就自动把它加到了 <code>AppModule</code> 中。</p>
<p>打开 <code>src/app/app.module.ts</code> 就会发现 <code>HeroesComponent</code> 已经在顶部导入过了。</p>
<p><code>HeroesComponent</code> 也已经声明在了 <code>@NgModule.declarations</code> 数组中。</p>
<p><code>AppModule</code> 声明了应用中的所有组件，<code>AppComponent</code> 和 <code>HeroesComponent</code>。</p>
<h2 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h2><ul>
<li>使用 CLI 创建了第二个组件 <code>HeroesComponent</code></li>
<li>把 <code>HeroesComponent</code> 添加到了壳组件 <code>AppComponent</code> 中，以便显示它</li>
<li>使用 <code>UppercasePipe</code> 来格式化英雄的名字</li>
<li>用 <code>ngModel</code> 指令实现了双向数据绑定</li>
<li>了解了 <code>AppModule</code></li>
<li>把 <code>FormsModule</code> 导入了 <code>AppModule</code>，以便 Angular 能识别并应用 <code>ngModel</code> 指令</li>
<li>知道了把组件声明到 <code>AppModule</code> 是很重要的，并认识到 CLI 会自动帮声明它</li>
</ul>
<h1 id="2-显示英雄列表"><a href="#2-显示英雄列表" class="headerlink" title="2 显示英雄列表"></a>2 显示英雄列表</h1><p>接下来将扩展《英雄之旅》应用，让它显示一个英雄列表，并允许用户选择一个英雄，查看该英雄的详细信息。</p>
<h2 id="2-1-创建模拟的英雄数据"><a href="#2-1-创建模拟的英雄数据" class="headerlink" title="2.1 创建模拟的英雄数据"></a>2.1 创建模拟的英雄数据</h2><p>需要一些英雄数据以供显示。</p>
<p>最终，会从远端的数据服务器获取它。不过目前，要先创建一些<em>模拟的英雄数据</em>，并假装它们是从服务器上取到的。</p>
<p>在 <code>src/app/</code> 文件夹中创建一个名叫 <code>mock-heroes.ts</code> 的文件。定义一个包含十个英雄的常量数组 <code>HEROES</code>，并导出它。该文件是这样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HEROES: Hero[] = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dr. Nice&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">13</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bombasto&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Celeritas&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Magneta&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RubberMan&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dynama&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dr. IQ&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">19</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Magma&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tornado&#x27;</span> &#125;<br>];<br></code></pre></div></td></tr></table></figure>



<h2 id="2-2-显示这些英雄"><a href="#2-2-显示这些英雄" class="headerlink" title="2.2 显示这些英雄"></a>2.2 显示这些英雄</h2><p>打开 <code>HeroesComponent</code> 类文件，并导入模拟的 <code>HEROES</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HEROES &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mock-heroes&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>往类中添加一个 <code>heroes</code> 属性，这样可以暴露出这个 <code>HEROES</code> 数组，以供绑定。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br><br>  heroes = HEROES;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="2-2-1-使用-ngFor-列出这些英雄"><a href="#2-2-1-使用-ngFor-列出这些英雄" class="headerlink" title="2.2.1 使用 *ngFor 列出这些英雄"></a>2.2.1 使用 <code>*ngFor</code> 列出这些英雄</h3><p>打开 <code>HeroesComponent</code> 的模板文件，并做如下修改：</p>
<ol>
<li>在顶部添加 <code>&lt;h2&gt;</code>，。</li>
<li>在它下面添加一个 HTML 无序列表 ( <code>&lt;ul&gt;</code> ) 元素。</li>
<li>在 <code>&lt;ul&gt;</code> 中插入 <code>&lt;li&gt;</code> &gt;。</li>
<li>在 <code>&lt;li&gt;</code> 中放一个 <code>&lt;button&gt;</code> 元素，以便在 <code>&lt;span&gt;</code> 元素中显示单个 <code>hero</code> 的属性。</li>
<li>点缀上一些 CSS 类（稍后还会添加更多 CSS 样式）。</li>
</ol>
<p>做完之后应该是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>My Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>由于属性 ‘hero’ 不存在，因此会显示一个错误。要访问每个英雄并列出所有英雄，请在 <code>&lt;li&gt;</code> 上添加 <code>*ngFor</code> 以遍历英雄列表：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://angular.cn/guide/built-in-directives#ngFor"><code>*ngFor</code></a> 是一个 Angular 的复写器（repeater）指令。它会为列表中的每项数据复写它的宿主元素。</p>
<p>这个例子中涉及的语法如下：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;li&gt;</code></td>
<td>宿主元素。</td>
</tr>
<tr>
<td><code>heroes</code></td>
<td>来自 <code>HeroesComponent</code> 类的存放模拟（mock）英雄的列表。</td>
</tr>
<tr>
<td><code>hero</code></td>
<td>保存列表每次迭代的当前 hero 对象。</td>
</tr>
</tbody></table>
<p>不要忘了 <code>ngFor</code> 前面的星号（<code>*</code>），它是该语法中的关键部分。</p>
<p>浏览器刷新之后，英雄列表出现了。</p>
<p><strong>注意</strong>：<br>在 <code>&lt;li&gt;</code> 元素中，我们将英雄的详细信息包装在 <code>&lt;button&gt;</code> 元素中。稍后我们使 hero 可点击，并且出于无障碍性的目的，最好使用本机交互式 HTML 元素（例如 <code>&lt;button&gt;</code>），而不是向非交互式元素添加事件侦听器（例如 <code>&lt;li&gt;</code>）。</p>
<h3 id="2-2-2-给英雄列表“美容”"><a href="#2-2-2-给英雄列表“美容”" class="headerlink" title="2.2.2 给英雄列表“美容”"></a>2.2.2 给英雄列表“美容”</h3><p>英雄列表应该富有吸引力，并且当用户把鼠标移到某个英雄上和从列表中选中某个英雄时，应该给出视觉反馈。</p>
<p>我们曾在 <code>styles.css</code> 中为整个应用设置了一些基础的样式。但那个样式表并不包含英雄列表所需的样式。</p>
<p>固然，可以把更多样式加入到 <code>styles.css</code>，并且放任它随着添加更多组件而不断膨胀。</p>
<p>但还有更好的方式。可以定义属于特定组件的私有样式，并且让组件所需的一切（代码、HTML 和 CSS）都放在一起。</p>
<p>这种方式让我们在其它地方复用该组件更加容易，并且即使全局样式和这里不一样，组件也仍然具有期望的外观。</p>
<p>我们可以用多种方式定义私有样式，或者内联在 <code>@Component.styles</code> 数组中，或者在 <code>@Component.styleUrls</code> 所指出的样式表文件中。</p>
<p>当 CLI 生成 <code>HeroesComponent</code> 时，它也同时为 <code>HeroesComponent</code> 创建了空白的 <code>heroes.component.css</code> 样式表文件，并且让 <code>@Component.styleUrls</code> 指向它，就像这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./heroes.component.html&#x27;</span>,<br>  styleUrls: [<span class="hljs-string">&#x27;./heroes.component.css&#x27;</span>]<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>打开 <code>heroes.component.css</code> 文件，并且把 <code>HeroesComponent</code> 的私有 CSS 样式粘贴进去。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* HeroesComponent&#x27;s private CSS styles */</span><br><span class="hljs-selector-class">.heroes</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2em</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">list-style-type</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">15em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#EEE</span>;<br>  <span class="hljs-attribute">margin</span>: .<span class="hljs-number">5em</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: stretch;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1.8em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2c3a41</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e6e6e6</span>;<br>  <span class="hljs-attribute">left</span>: .<span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#525252</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fafafa</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.selected</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.selected</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#505050</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.selected</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-class">.badge</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">font-size</span>: small;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.8em</span> <span class="hljs-number">0.7em</span> <span class="hljs-number">0</span> <span class="hljs-number">0.7em</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#405061</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">margin-right</span>: .<span class="hljs-number">8em</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heroes</span> <span class="hljs-selector-class">.name</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: center;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><code>@Component</code> 元数据中指定的样式和样式表都是局限于该组件的。<code>heroes.component.css</code> 中的样式只会作用于 <code>HeroesComponent</code>，既不会影响到组件外的 HTML，也不会影响到其它组件中的 HTML。</p>
<h2 id="2-3-查看详情"><a href="#2-3-查看详情" class="headerlink" title="2.3 查看详情"></a>2.3 查看详情</h2><p>当用户在此列表中点击一个英雄时，该组件应该在页面底部显示所选英雄的详情。</p>
<p>在本节，我们将监听英雄条目的点击事件，并显示与更新英雄的详情。</p>
<h3 id="2-3-1-添加click事件绑定"><a href="#2-3-1-添加click事件绑定" class="headerlink" title="2.3.1 添加click事件绑定"></a>2.3.1 添加click事件绑定</h3><p>为 <code>&lt;li&gt;</code> 中的 <code>&lt;button&gt;</code> 上添加一个点击事件的绑定代码：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;onSelect(hero)&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>这是 Angular <a target="_blank" rel="noopener" href="https://angular.cn/guide/event-binding">事件绑定</a> 语法的例子。</p>
<p><code>click</code> 外面的圆括号会让 Angular 监听这个 <code>&lt;button&gt;</code> 元素的 <code>click</code> 事件。 当用户点击 <code>&lt;button&gt;</code> 时，Angular 就会执行表达式 <code>onSelect(hero)</code>。</p>
<p>下一部分，会在 <code>HeroesComponent</code> 上定义一个 <code>onSelect()</code> 方法，用来显示 <code>*ngFor</code> 表达式所定义的那个英雄（<code>hero</code>）。</p>
<h3 id="2-3-2-添加click事件处理器"><a href="#2-3-2-添加click事件处理器" class="headerlink" title="2.3.2 添加click事件处理器"></a>2.3.2 添加click事件处理器</h3><p>把该组件的 <code>hero</code> 属性改名为 <code>selectedHero</code>，但不要为它赋值。 因为应用刚刚启动时并没有<em>所选英雄</em>。</p>
<p>添加如下 <code>onSelect()</code> 方法，它会把模板中被点击的英雄赋值给组件的 <code>selectedHero</code> 属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">selectedHero?: Hero;<br>onSelect(hero: Hero): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.selectedHero = hero;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="2-3-3-添加详情区"><a href="#2-3-3-添加详情区" class="headerlink" title="2.3.3 添加详情区"></a>2.3.3 添加详情区</h3><p>现在，组件的模板中有一个列表。要想点击列表中的一个英雄，并显示该英雄的详情，需要在模板中留一个区域，用来显示这些详情。在 <code>heroes.component.html</code> 中该列表的紧下方，添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;selectedHero&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;selectedHero.name | uppercase&#125;&#125; Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>id: &#123;&#123;selectedHero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;hero-name&quot;</span>&gt;</span>Hero name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hero-name&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;selectedHero.name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>只有在选择英雄时才会显示英雄详细信息。最初创建组件时，没有所选的 hero，因此我们将 <code>*ngIf</code> 指令添加到包装 hero 详细信息的 <code>&lt;div&gt;</code> 中，以指示 Angular 仅在实际定义 <code>selectedHero</code> 时（在它被通过点击英雄来选择）。</p>
<p>不要忘了 <code>ngIf</code> 前面的星号（<code>*</code>），它是该语法中的关键部分。</p>
<h3 id="2-3-4-为选定的英雄设置样式"><a href="#2-3-4-为选定的英雄设置样式" class="headerlink" title="2.3.4 为选定的英雄设置样式"></a>2.3.4 为选定的英雄设置样式</h3><p>为了标出选定的英雄，可以在<a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt2#styles">以前添加过的样式中</a>增加 CSS 类 <code>.selected</code>。若要把 <code>.selected</code> 类应用于此 <code>&lt;li&gt;</code> 上，请使用类绑定。</p>
<p><img src="../img/Angular-tour-of-heros/2-3-4.png" srcset="/img/loading.gif" lazyload alt="2-3-4"></p>
<p>Angular 的<a target="_blank" rel="noopener" href="https://angular.cn/guide/class-binding">类绑定</a>可以有条件地添加和删除 CSS 类。只需将 <code>[class.some-css-class]=&quot;some-condition&quot;</code> 添加到要设置样式的元素即可。</p>
<p>在 <code>HeroesComponent</code> 模板中的 <code>&lt;button&gt;</code> 元素上添加 <code>[class.selected]</code> 绑定，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">[class.selected]=&quot;hero === selectedHero&quot;<br></code></pre></div></td></tr></table></figure>

<p>如果当前行的英雄和 <code>selectedHero</code> 相同，Angular 就会添加 CSS 类 <code>selected</code>，否则就会移除它。</p>
<p>最终的 <code>&lt;li&gt;</code> 是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> [<span class="hljs-attr">class.selected</span>]=<span class="hljs-string">&quot;hero === selectedHero&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;onSelect(hero)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><ul>
<li>英雄之旅应用在一个主从视图中显示了英雄列表。</li>
<li>用户可以选择一个英雄，并查看该英雄的详情。</li>
<li>使用 <code>*ngFor</code> 显示了一个列表。</li>
<li>使用 <code>*ngIf</code> 来根据条件包含或排除了一段 HTML。</li>
<li>可以用 <code>class</code> 绑定来切换 CSS 的样式类。</li>
</ul>
<h1 id="3-创建主从组件"><a href="#3-创建主从组件" class="headerlink" title="3 创建主从组件"></a>3 创建主从组件</h1><p>此刻，<code>HeroesComponent</code> 同时显示了英雄列表和所选英雄的详情。</p>
<p>把所有特性都放在同一个组件中，将会使应用“长大”后变得不可维护。要把大型组件拆分成小一点的子组件，每个子组件都要集中精力处理某个特定的任务或工作流。</p>
<p>本页面中，将迈出第一步 —— 把英雄详情移入一个独立的、可复用的 <code>HeroDetailComponent</code>。</p>
<p><code>HeroesComponent</code> 将仅仅用来表示英雄列表。<code>HeroDetailComponent</code> 将用来表示所选英雄的详情。</p>
<h2 id="3-1-制作HeroDetailComponent"><a href="#3-1-制作HeroDetailComponent" class="headerlink" title="3.1 制作HeroDetailComponent"></a>3.1 制作HeroDetailComponent</h2><p>使用 Angular CLI 生成一个名叫 <code>hero-detail</code> 的新组件。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> component hero-detail<br></code></pre></div></td></tr></table></figure>

<p>这个命令会做这些事：</p>
<ul>
<li>创建目录 <code>src/app/hero-detail</code>。</li>
</ul>
<p>在这个目录中会生成四个文件：</p>
<ul>
<li>作为组件样式的 CSS 文件。</li>
<li>作为组件模板的 HTML 文件。</li>
<li>存放组件类 <code>HeroDetailComponent</code> 的 TypeScript 文件。</li>
<li><code>HeroDetailComponent</code> 类的测试文件。</li>
</ul>
<p>该命令还会把 <code>HeroDetailComponent</code> 添加到 <code>src/app/app.module.ts</code> 文件中 <code>@NgModule</code> 的 <code>declarations</code> 列表中。</p>
<h3 id="3-1-1-编写模板"><a href="#3-1-1-编写模板" class="headerlink" title="3.1.1 编写模板"></a>3.1.1 编写模板</h3><p>从 <code>HeroesComponent</code> 模板的底部把表示英雄详情的 HTML 代码剪切粘贴到所生成的 <code>HeroDetailComponent</code> 模板中。</p>
<p>所粘贴的 HTML 引用了 <code>selectedHero</code>。新的 <code>HeroDetailComponent</code> 可以展示<em>任意</em>英雄，而不仅仅所选的。因此还要把模板中的所有 <code>selectedHero</code> 替换为 <code>hero</code>。</p>
<p>完工之后，<code>HeroDetailComponent</code> 的模板应该是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;hero&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;hero.name | uppercase&#125;&#125; Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>id: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;hero-name&quot;</span>&gt;</span>Hero name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hero-name&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;hero.name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<h3 id="3-1-2-添加-Input-hero-属性"><a href="#3-1-2-添加-Input-hero-属性" class="headerlink" title="3.1.2 添加 @Input() hero 属性"></a>3.1.2 添加 <code>@Input() hero</code> 属性</h3><p><code>HeroDetailComponent</code> 模板中绑定了组件中的 <code>hero</code> 属性，它的类型是 <code>Hero</code>。</p>
<p>打开 <code>HeroDetailComponent</code> 类文件，并导入 <code>Hero</code> 符号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p><code>hero</code> 属性<a target="_blank" rel="noopener" href="https://angular.cn/guide/inputs-outputs">必须是一个带有 <code>@Input()</code> 装饰器的输入属性</a>，因为<em>外部的</em> <code>HeroesComponent</code> 组件<a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt3#heroes-component-template">将会绑定到它</a>。就像这样：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">app-hero-detail</span> [<span class="hljs-attr">hero</span>]=<span class="hljs-string">&quot;selectedHero&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-hero-detail</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure>

<p>修改 <code>@angular/core</code> 的导入语句，导入 <code>Input</code> 符号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>添加一个带有 <code>@Input()</code> 装饰器的 <code>hero</code> 属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Input</span>() hero?: Hero;<br></code></pre></div></td></tr></table></figure>

<p>这就是要对 <code>HeroDetailComponent</code> 类做的唯一一项修改。没有其它属性，也没有展示逻辑。这个组件所做的只是通过 <code>hero</code> 属性接收一个英雄对象，并显示它。</p>
<h2 id="3-2-显示HeroDetailComponent"><a href="#3-2-显示HeroDetailComponent" class="headerlink" title="3.2 显示HeroDetailComponent"></a>3.2 显示HeroDetailComponent</h2><p><code>HeroesComponent</code> 会自行显示英雄的详情，但后面我们要移除这部分。本节会指导把这部分逻辑委派给 <code>HeroDetailComponent</code>。</p>
<p>这两个组件将会具有父子关系。当用户从列表中选择了某个英雄时，父组件 <code>HeroesComponent</code> 将通过把要显示的新英雄发送给子组件 <code>HeroDetailComponent</code>，来控制子组件。</p>
<p>不用修改 <code>HeroesComponent</code> <em>类</em>，但是要修改它的<em>模板</em>。</p>
<h3 id="3-2-1-修改HeroesComponent的模板"><a href="#3-2-1-修改HeroesComponent的模板" class="headerlink" title="3.2.1 修改HeroesComponent的模板"></a>3.2.1 修改HeroesComponent的模板</h3><p><code>HeroDetailComponent</code> 的选择器是 <code>&#39;app-hero-detail&#39;</code>。把 <code>&lt;app-hero-detail&gt;</code> 添加到 <code>HeroesComponent</code> 模板的底部，以便把英雄详情的视图显示到那里。</p>
<p>把 <code>HeroesComponent.selectedHero</code> 绑定到该元素的 <code>hero</code> 属性，就像这样。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-hero-detail</span> [<span class="hljs-attr">hero</span>]=<span class="hljs-string">&quot;selectedHero&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-hero-detail</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><code>[hero]=&quot;selectedHero&quot;</code> 是 Angular 的<a target="_blank" rel="noopener" href="https://angular.cn/guide/property-binding">属性绑定</a>语法。</p>
<p>这是一种<em>单向</em>数据绑定。从 <code>HeroesComponent</code> 的 <code>selectedHero</code> 属性绑定到目标元素的 <code>hero</code> 属性，并映射到了 <code>HeroDetailComponent</code> 的 <code>hero</code> 属性。</p>
<p>现在，当用户在列表中点击某个英雄时，<code>selectedHero</code> 就改变了。当 <code>selectedHero</code> 改变时，<em>属性绑定</em>会修改 <code>HeroDetailComponent</code> 的 <code>hero</code> 属性，<code>HeroDetailComponent</code> 就会显示这个新的英雄。</p>
<p>修改后的 <code>HeroesComponent</code> 的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>My Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> [<span class="hljs-attr">class.selected</span>]=<span class="hljs-string">&quot;hero === selectedHero&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;onSelect(hero)&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">app-hero-detail</span> [<span class="hljs-attr">hero</span>]=<span class="hljs-string">&quot;selectedHero&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-hero-detail</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>浏览器刷新，应用又像以前一样开始工作了。</p>
<h2 id="3-3-有哪些变化"><a href="#3-3-有哪些变化" class="headerlink" title="3.3 有哪些变化"></a>3.3 有哪些变化</h2><p>像以前一样，一旦用户点击了一个英雄的名字，该英雄的详情就显示在了英雄列表下方。现在，<code>HeroDetailComponent</code> 负责显示那些详情，而不再是 <code>HeroesComponent</code>。</p>
<p>把原来的 <code>HeroesComponent</code> 重构成两个组件带来了一些优点，无论是现在还是未来：</p>
<ol>
<li>通过缩减 <code>HeroesComponent</code> 的职责缩小了该组件。</li>
<li>可以把 <code>HeroDetailComponent</code> 改进成一个功能丰富的英雄编辑器，而不用改动父组件 <code>HeroesComponent</code>。</li>
<li>可以改进 <code>HeroesComponent</code>，而不用改动英雄详情视图。</li>
<li>将来可以在其它组件的模板中重复使用 <code>HeroDetailComponent</code>。</li>
</ol>
<h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h2><ul>
<li>创建了一个独立的、可复用的 <code>HeroDetailComponent</code> 组件。</li>
<li>用<a target="_blank" rel="noopener" href="https://angular.cn/guide/property-binding">属性绑定</a>语法来让父组件 <code>HeroesComponent</code> 可以控制子组件 <code>HeroDetailComponent</code>。</li>
<li>用 <a target="_blank" rel="noopener" href="https://angular.cn/guide/inputs-outputs"><code>@Input</code> 装饰器</a>来让 <code>hero</code> 属性可以在外部的 <code>HeroesComponent</code> 中绑定。</li>
</ul>
<h1 id="4-添加服务"><a href="#4-添加服务" class="headerlink" title="4 添加服务"></a>4 添加服务</h1><p>英雄之旅的 <code>HeroesComponent</code> 目前获取和显示的都是模拟数据。</p>
<p>本节课的重构完成之后，<code>HeroesComponent</code> 变得更精简，并且聚焦于为它的视图提供支持。这也让它更容易使用模拟服务进行单元测试。</p>
<h2 id="4-1-为什么需要服务"><a href="#4-1-为什么需要服务" class="headerlink" title="4.1 为什么需要服务"></a>4.1 为什么需要服务</h2><p>组件不应该直接获取或保存数据，它们不应该了解是否在展示假数据。它们应该聚焦于展示数据，而把数据访问的职责委托给某个服务。</p>
<p>本节课，将创建一个 <code>HeroService</code>，应用中的所有类都可以使用它来获取英雄列表。 不要使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/new"><code>new</code>关键字</a>来创建此服务，而要依靠 Angular 的<a target="_blank" rel="noopener" href="https://angular.cn/guide/dependency-injection"><em>依赖注入</em></a>机制把它注入到 <code>HeroesComponent</code> 的构造函数中。</p>
<p>服务是在多个“互相不知道”的类之间共享信息的好办法。将创建一个 <code>MessageService</code>，并且把它注入到两个地方。</p>
<ul>
<li>注入到 <code>HeroService</code> 中，它会使用该服务发送消息。</li>
<li>注入到 <code>MessagesComponent</code> 中，它会显示其中的消息。当用户点击某个英雄时，它还会显示该英雄的 ID。</li>
</ul>
<h2 id="4-2-创建HeroService"><a href="#4-2-创建HeroService" class="headerlink" title="4.2 创建HeroService"></a>4.2 创建HeroService</h2><p>使用 Angular CLI 创建一个名叫 <code>hero</code> 的服务。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> service hero<br></code></pre></div></td></tr></table></figure>

<p>该命令会在 <code>src/app/hero.service.ts</code> 中生成 <code>HeroService</code> 类的骨架，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>(&#123;<br>  providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroService</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-2-1-Injectable-服务"><a href="#4-2-1-Injectable-服务" class="headerlink" title="4.2.1 @Injectable() 服务"></a>4.2.1 <code>@Injectable()</code> 服务</h3><p>注意，这个新的服务导入了 Angular 的 <code>Injectable</code> 符号，并且给这个服务类添加了 <code>@Injectable()</code> 装饰器。 它把这个类标记为<em>依赖注入系统</em>的参与者之一。<code>HeroService</code> 类将会提供一个可注入的服务，并且它还可以拥有自己的待注入的依赖。 目前它还没有依赖，但是很快就会有了。</p>
<p><code>@Injectable()</code> 装饰器会接受该服务的元数据对象，就像 <code>@Component()</code> 对组件类的作用一样。</p>
<h3 id="4-2-2-获取英雄数据"><a href="#4-2-2-获取英雄数据" class="headerlink" title="4.2.2 获取英雄数据"></a>4.2.2 获取英雄数据</h3><p><code>HeroService</code> 可以从任何地方获取数据：Web 服务、本地存储（LocalStorage）或一个模拟的数据源。</p>
<p>从组件中移除数据访问逻辑，意味着将来任何时候都可以改变目前的实现方式，而不用改动任何组件。这些组件不需要了解该服务的内部实现。</p>
<p>这节课中的实现仍然会提供<em>模拟的英雄列表</em>。</p>
<p>导入 <code>Hero</code> 和 <code>HEROES</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; HEROES &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mock-heroes&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>添加一个 <code>getHeroes</code> 方法，让它返回<em>模拟的英雄列表</em>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): Hero[] &#123;<br>  <span class="hljs-keyword">return</span> HEROES;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="4-3-提供HeroService"><a href="#4-3-提供HeroService" class="headerlink" title="4.3 提供HeroService"></a>4.3 提供HeroService</h2><p>必须先注册一个<em>服务提供者</em>，来让 <code>HeroService</code> 在依赖注入系统中可用，Angular 才能把它注入到 <code>HeroesComponent</code> 中。所谓服务提供者就是某种可用来创建或交付一个服务的东西；在这里，它通过实例化 <code>HeroService</code> 类，来提供该服务。</p>
<p>为了确保 <code>HeroService</code> 可以提供该服务，就要使用<em>注入器</em>来注册它。注入器是一个对象，负责当应用要求获取它的实例时选择和注入该提供者。</p>
<p>默认情况下，Angular CLI 命令 <code>ng generate service</code> 会通过给 <code>@Injectable()</code> 装饰器添加 <code>providedIn: &#39;root&#39;</code> 元数据的形式，用<em>根注入器</em>将我们的服务注册成为提供者。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Injectable</span>(&#123;<br>  providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>当在顶层提供该服务时，Angular 就会为 <code>HeroService</code> 创建一个单一的、共享的实例，并把它注入到任何想要它的类上。在 <code>@Injectable</code> 元数据中注册该提供者，还能允许 Angular 通过移除那些完全没有用过的服务来进行优化。</p>
<p>现在 <code>HeroService</code> 已经准备好插入到 <code>HeroesComponent</code> 中了。</p>
<h2 id="4-4-修改HeroesComponent"><a href="#4-4-修改HeroesComponent" class="headerlink" title="4.4 修改HeroesComponent"></a>4.4 修改HeroesComponent</h2><p>打开 <code>HeroesComponent</code> 类文件。</p>
<p>删除 <code>HEROES</code> 的导入语句，因为以后不会再用它了。转而导入 <code>HeroService</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HeroService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero.service&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>把 <code>heroes</code> 属性的定义改为一句简单的声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">heroes: Hero[] = [];<br></code></pre></div></td></tr></table></figure>



<h3 id="4-4-1-注入HeroService"><a href="#4-4-1-注入HeroService" class="headerlink" title="4.4.1 注入HeroService"></a>4.4.1 注入HeroService</h3><p>往构造函数中添加一个私有的 <code>heroService</code>，其类型为 <code>HeroService</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroService</span>)</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>这个参数声明了一个私有 <code>heroService</code> 属性，同时把它标记为一个 <code>HeroService</code> 的注入点。</p>
<p>当 Angular 创建 <code>HeroesComponent</code> 时，<a target="_blank" rel="noopener" href="https://angular.cn/guide/dependency-injection">依赖注入</a>系统就会把这个 <code>heroService</code> 参数设置为 <code>HeroService</code> 的单例对象。</p>
<h3 id="4-4-2-添加-getHeroes"><a href="#4-4-2-添加-getHeroes" class="headerlink" title="4.4.2 添加 getHeroes()"></a>4.4.2 添加 <code>getHeroes()</code></h3><p>创建一个方法，以从服务中获取这些英雄数据。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.heroes = <span class="hljs-built_in">this</span>.heroService.getHeroes();<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-4-3-在-ngOnInit-中调用它"><a href="#4-4-3-在-ngOnInit-中调用它" class="headerlink" title="4.4.3 在 ngOnInit() 中调用它"></a>4.4.3 在 <code>ngOnInit()</code> 中调用它</h3><p>固然可以在构造函数中调用 <code>getHeroes()</code>，但那不是最佳实践。</p>
<p>让构造函数保持简单，只做最小化的初始化操作，比如把构造函数的参数赋值给属性。构造函数不应该<em>做任何事</em>。它当然不应该调用某个函数来向远端服务（比如真实的数据服务）发起 HTTP 请求。</p>
<p>而是选择在 <a target="_blank" rel="noopener" href="https://angular.cn/guide/lifecycle-hooks"><em>ngOnInit 生命周期钩子</em></a>中调用 <code>getHeroes()</code>，之后 Angular 会在构造出 <code>HeroesComponent</code> 的实例之后的某个合适的时机调用 <code>ngOnInit()</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.getHeroes();<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-4-4-查看运行效果"><a href="#4-4-4-查看运行效果" class="headerlink" title="4.4.4 查看运行效果"></a>4.4.4 查看运行效果</h3><p>刷新浏览器，该应用仍运行的一如既往。显示英雄列表，并且当点击某个英雄的名字时显示出英雄详情视图。</p>
<h2 id="4-5-可观察的数据"><a href="#4-5-可观察的数据" class="headerlink" title="4.5 可观察的数据"></a>4.5 可观察的数据</h2><p><code>HeroService.getHeroes()</code> 的函数签名是<em>同步的</em>，它所隐含的假设是 <code>HeroService</code> 总是能同步获取英雄列表数据。而 <code>HeroesComponent</code> 也同样假设能同步取到 <code>getHeroes()</code> 的结果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-built_in">this</span>.heroes = <span class="hljs-built_in">this</span>.heroService.getHeroes();<br></code></pre></div></td></tr></table></figure>

<p>这在真实的应用中几乎是不可能的。现在能这么做，只是因为目前该服务返回的是<em>模拟数据</em>。不过很快，该应用就要从远端服务器获取英雄数据了，而那天生就是<em>异步</em>操作。</p>
<p><code>HeroService</code> 必须等服务器给出响应，而 <code>getHeroes()</code> 不能立即返回英雄数据，浏览器也不会在该服务等待期间停止响应。</p>
<p><code>HeroService.getHeroes()</code> 必须具有某种形式的<em>异步函数签名</em>。</p>
<p>这节课，<code>HeroService.getHeroes()</code> 将会返回 <code>Observable</code>，部分原因在于它最终会使用 Angular 的 <code>HttpClient.get</code> 方法来获取英雄数据，而 <code>HttpClient.get()</code> 会返回 <code>Observable</code>。</p>
<h3 id="4-5-1-可观察对象版本的HeroService"><a href="#4-5-1-可观察对象版本的HeroService" class="headerlink" title="4.5.1 可观察对象版本的HeroService"></a>4.5.1 可观察对象版本的HeroService</h3><p><code>Observable</code> 是 <a target="_blank" rel="noopener" href="https://rxjs.dev/">RxJS 库</a>中的一个关键类。</p>
<p>在稍后的 HTTP 教程中，就会知道 Angular <code>HttpClient</code> 的方法会返回 RxJS 的 <code>Observable</code>。这节课，将使用 RxJS 的 <code>of()</code> 函数来模拟从服务器返回数据。</p>
<p>打开 <code>HeroService</code> 文件，并从 RxJS 中导入 <code>Observable</code> 和 <code>of</code> 符号。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Observable, <span class="hljs-keyword">of</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>把 <code>getHeroes()</code> 方法改成这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">const</span> heroes = <span class="hljs-keyword">of</span>(HEROES);<br>  <span class="hljs-keyword">return</span> heroes;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>of(HEROES)</code> 会返回一个 <code>Observable&lt;Hero[]&gt;</code>，它会发出单个值，这个值就是这些模拟英雄的数组。</p>
<p>在HTTP教程中，我们将会调用 <code>HttpClient.get&lt;Hero[]&gt;()</code> 它也同样返回一个 <code>Observable&lt;Hero[]&gt;</code>，它也会发出单个值，这个值就是来自 HTTP 响应体中的英雄数组。</p>
<h3 id="4-5-2-在HeroesComponent中订阅"><a href="#4-5-2-在HeroesComponent中订阅" class="headerlink" title="4.5.2 在HeroesComponent中订阅"></a>4.5.2 在HeroesComponent中订阅</h3><p><code>HeroService.getHeroes</code> 方法之前返回一个 <code>Hero[]</code>，现在它返回的是 <code>Observable&lt;Hero[]&gt;</code>。</p>
<p>必须在 <code>HeroesComponent</code> 中也向本服务中的这种形式看齐。</p>
<p>找到 <code>getHeroes</code> 方法，并且把它替换为如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.heroService.getHeroes()<br>      .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Observable.subscribe()</code> 是关键的差异点。</p>
<p>上一个版本把英雄的数组赋值给了该组件的 <code>heroes</code> 属性。这种赋值是<em>同步</em>的，这里包含的假设是服务器能立即返回英雄数组或者浏览器能在等待服务器响应时冻结界面。</p>
<p>当 <code>HeroService</code> 真的向远端服务器发起请求时，这种方式就行不通了。</p>
<p>新的版本等待 <code>Observable</code> 发出这个英雄数组，这可能立即发生，也可能会在几分钟之后。然后，<code>subscribe()</code> 方法把这个英雄数组传给这个回调函数，该函数把英雄数组赋值给组件的 <code>heroes</code> 属性。</p>
<p>使用这种异步方式，当 <code>HeroService</code> 从远端服务器获取英雄数据时，就<em>可以工作了</em>。</p>
<h2 id="4-6-显示消息"><a href="#4-6-显示消息" class="headerlink" title="4.6 显示消息"></a>4.6 显示消息</h2><p>这一节将：</p>
<ul>
<li>添加一个 <code>MessagesComponent</code>，它在屏幕的底部显示应用中的消息。</li>
<li>创建一个可注入的、全应用级别的 <code>MessageService</code>，用于发送要显示的消息。</li>
<li>把 <code>MessageService</code> 注入到 <code>HeroService</code> 中。</li>
<li>当 <code>HeroService</code> 成功获取了英雄数据时显示一条消息。</li>
</ul>
<h3 id="4-6-1-创建MessagesComponent"><a href="#4-6-1-创建MessagesComponent" class="headerlink" title="4.6.1 创建MessagesComponent"></a>4.6.1 创建MessagesComponent</h3><p>使用 CLI 创建 <code>MessagesComponent</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> component messages<br></code></pre></div></td></tr></table></figure>

<p>CLI 在 <code>src/app/messages</code> 中创建了组件文件，并且把 <code>MessagesComponent</code> 声明在了 <code>AppModule</code> 中。</p>
<p>修改 <code>AppComponent</code> 的模板来显示所生成的 <code>MessagesComponent</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-heroes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-heroes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-messages</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-messages</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>可以在页面的底部看到来自的 <code>MessagesComponent</code> 的默认内容。</p>
<h3 id="4-6-2-创建MessageService"><a href="#4-6-2-创建MessageService" class="headerlink" title="4.6.2 创建MessageService"></a>4.6.2 创建MessageService</h3><p>使用 CLI 在 <code>src/app</code> 中创建 <code>MessageService</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> service message<br></code></pre></div></td></tr></table></figure>

<p>打开 <code>MessageService</code>，并把它的内容改成这样。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>(&#123;<br>  providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> </span>&#123;<br>  messages: <span class="hljs-built_in">string</span>[] = [];<br><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.messages.push(message);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.messages = [];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>该服务对外暴露了它的 <code>messages</code> 缓存，以及两个方法：<code>add()</code> 方法往缓存中添加一条消息，<code>clear()</code> 方法用于清空缓存。</p>
<h3 id="4-6-3-把它注入到HeroService中"><a href="#4-6-3-把它注入到HeroService中" class="headerlink" title="4.6.3 把它注入到HeroService中"></a>4.6.3 把它注入到HeroService中</h3><p>在 <code>HeroService</code> 中导入 <code>MessageService</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; MessageService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./message.service&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>修改这个构造函数，添加一个私有的 <code>messageService</code> 属性参数。Angular 将会在创建 <code>HeroService</code> 时把 <code>MessageService</code> 的单例注入到这个属性中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> messageService: MessageService</span>)</span> &#123; &#125;<br></code></pre></div></td></tr></table></figure>

<p>这是一个典型的“服务中的服务”场景：把 <code>MessageService</code> 注入到了 <code>HeroService</code> 中，而 <code>HeroService</code> 又被注入到了 <code>HeroesComponent</code> 中。</p>
<h3 id="4-6-4-从HeroService中发送一条消息"><a href="#4-6-4-从HeroService中发送一条消息" class="headerlink" title="4.6.4 从HeroService中发送一条消息"></a>4.6.4 从HeroService中发送一条消息</h3><p>修改 <code>getHeroes()</code> 方法，在获取到英雄数组时发送一条消息。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">const</span> heroes = <span class="hljs-keyword">of</span>(HEROES);<br>  <span class="hljs-built_in">this</span>.messageService.add(<span class="hljs-string">&#x27;HeroService: fetched heroes&#x27;</span>);<br>  <span class="hljs-keyword">return</span> heroes;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-6-5-从HeroService中显示消息"><a href="#4-6-5-从HeroService中显示消息" class="headerlink" title="4.6.5 从HeroService中显示消息"></a>4.6.5 从HeroService中显示消息</h3><p><code>MessagesComponent</code> 可以显示所有消息，包括当 <code>HeroService</code> 获取到英雄数据时发送的那条。</p>
<p>打开 <code>MessagesComponent</code>，并且导入 <code>MessageService</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; MessageService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../message.service&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>修改构造函数，添加一个 <strong>public</strong> 的 <code>messageService</code> 属性。Angular 将会在创建 <code>MessagesComponent</code> 的实例时 把 <code>MessageService</code> 的实例注入到这个属性中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> messageService: MessageService</span>)</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p>这个 <code>messageService</code> 属性必须是公共属性，因为将会在模板中绑定到它。</p>
<p>Angular 只会绑定到组件的<em>公共</em>属性。</p>
<h3 id="4-6-6-绑定到MessageService"><a href="#4-6-6-绑定到MessageService" class="headerlink" title="4.6.6 绑定到MessageService"></a>4.6.6 绑定到MessageService</h3><p>把 CLI 生成的 <code>MessagesComponent</code> 的模板改成这样。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;messageService.messages.length&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Messages<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clear&quot;</span></span><br><span class="hljs-tag">          (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;messageService.clear()&quot;</span>&gt;</span>Clear messages<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&#x27;let message of messageService.messages&#x27;</span>&gt;</span> &#123;&#123;message&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>这个模板直接绑定到了组件的 <code>messageService</code> 属性上。</p>
<table>
<thead>
<tr>
<th></th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>*ngIf</code></td>
<td>只有在有消息时才会显示消息区。</td>
</tr>
<tr>
<td><code>*ngFor</code></td>
<td>在一系列 <code>&lt;div&gt;</code> 元素中展示消息列表。</td>
</tr>
<tr>
<td>Angular <a target="_blank" rel="noopener" href="https://angular.cn/guide/event-binding">事件绑定</a></td>
<td>把按钮的 <code>click</code> 事件绑定到了 <code>MessageService.clear()</code>。</td>
</tr>
</tbody></table>
<p>当把最终代码某一页的内容添加到 <code>messages.component.css</code> 中时，这些消息会变得好看一些。</p>
<h2 id="4-7-为hero服务添加额外的消息"><a href="#4-7-为hero服务添加额外的消息" class="headerlink" title="4.7 为hero服务添加额外的消息"></a>4.7 为hero服务添加额外的消息</h2><p>下面的例子展示了当用户点击某个英雄时，如何发送和显示一条消息，以及如何显示该用户的选取历史。当学到后面的路由一章时，这会很有帮助。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; HeroService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero.service&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; MessageService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../message.service&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-heroes&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./heroes.component.html&#x27;</span>,<br>  styleUrls: [<span class="hljs-string">&#x27;./heroes.component.css&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br><br>  selectedHero?: Hero;<br><br>  heroes: Hero[] = [];<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroService, <span class="hljs-keyword">private</span> messageService: MessageService</span>)</span> &#123; &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.getHeroes();<br>  &#125;<br><br>  onSelect(hero: Hero): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.selectedHero = hero;<br>    <span class="hljs-built_in">this</span>.messageService.add(<span class="hljs-string">`HeroesComponent: Selected hero id=<span class="hljs-subst">$&#123;hero.id&#125;</span>`</span>);<br>  &#125;<br><br>  getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.heroService.getHeroes()<br>        .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>刷新浏览器，页面显示出了英雄列表。滚动到底部，就会在消息区看到来自 <code>HeroService</code> 的消息。点击 <strong>Clear messages</strong> 按钮，消息区不见了。</p>
<h2 id="4-8-小结"><a href="#4-8-小结" class="headerlink" title="4.8 小结"></a>4.8 小结</h2><ul>
<li>把数据访问逻辑重构到了 <code>HeroService</code> 类中</li>
<li>在根注入器中把 <code>HeroService</code> 注册为该服务的提供者，以便在别处可以注入它</li>
<li>使用 <a target="_blank" rel="noopener" href="https://angular.cn/guide/dependency-injection">Angular 依赖注入</a>机制把它注入到了组件中</li>
<li>给 <code>HeroService</code> 中获取数据的方法提供了一个异步的函数签名</li>
<li>发现了 <code>Observable</code> 以及 RxJS 库</li>
<li>使用 RxJS 的 <code>of()</code> 方法返回了一个模拟英雄数据的<em>可观察对象</em> (<code>Observable&lt;Hero[]&gt;</code>)</li>
<li>组件的 <code>ngOnInit</code> 生命周期钩子中调用 <code>HeroService</code> 方法，而不是构造函数中</li>
<li>创建了一个 <code>MessageService</code>，以便在类之间实现松耦合通讯</li>
<li><code>HeroService</code> 连同注入到它的服务 <code>MessageService</code> 一起，注入到了组件中</li>
</ul>
<h1 id="5-用路由添加导航支持"><a href="#5-用路由添加导航支持" class="headerlink" title="5 用路由添加导航支持"></a>5 用路由添加导航支持</h1><p>有一些《英雄之旅》的新需求：</p>
<ul>
<li>添加一个<em>仪表盘</em>视图</li>
<li>添加在<em>英雄列表</em>和<em>仪表盘</em>视图之间导航的能力</li>
<li>无论在哪个视图中点击一个英雄，都会导航到该英雄的详情页</li>
<li>在邮件中点击一个<em>深链接</em>，会直接打开一个特定英雄的详情视图</li>
</ul>
<p>完成时，用户就能像这样在应用中导航：</p>
<p><img src="../img/Angular-tour-of-heros/5.png" srcset="/img/loading.gif" lazyload alt="5"></p>
<h2 id="5-1-添加AppRoutingModule"><a href="#5-1-添加AppRoutingModule" class="headerlink" title="5.1 添加AppRoutingModule"></a>5.1 添加AppRoutingModule</h2><p>在 Angular 中，最好在一个独立的顶层模块中加载和配置路由器，它专注于路由功能，然后由根模块 <code>AppModule</code> 导入它。</p>
<p>按照惯例，这个模块类的名字叫做 <code>AppRoutingModule</code>，并且位于 <code>src/app</code> 下的 <code>app-routing.module.ts</code> 文件中。</p>
<p>使用 CLI 生成它。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> <span class="hljs-keyword">module</span> app-routing --flat --<span class="hljs-keyword">module</span>=app<br></code></pre></div></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>--flat</code></td>
<td>把这个文件放进了 <code>src/app</code> 中，而不是单独的目录中。</td>
</tr>
<tr>
<td><code>--module=app</code></td>
<td>告诉 CLI 把它注册到 <code>AppModule</code> 的 <code>imports</code> 数组中。</td>
</tr>
</tbody></table>
<p>生成的文件是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; CommonModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common&#x27;</span>;<br><br><span class="hljs-meta">@NgModule</span>(&#123;<br>  imports: [<br>    CommonModule<br>  ],<br>  declarations: []<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure>

<p>把它替换为如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; RouterModule, Routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; HeroesComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./heroes/heroes.component&#x27;</span>;<br><br><span class="hljs-keyword">const</span> routes: Routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;heroes&#x27;</span>, <span class="hljs-attr">component</span>: HeroesComponent &#125;<br>];<br><br><span class="hljs-meta">@NgModule</span>(&#123;<br>  imports: [RouterModule.forRoot(routes)],<br>  <span class="hljs-built_in">exports</span>: [RouterModule]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure>

<p>首先，<code>app-routing.module.ts</code> 会导入 <code>RouterModule</code> 和 <code>Routes</code>，以便该应用具有路由功能。配置好路由后，接着导入 <code>HeroesComponent</code>，它将告诉路由器要去什么地方。</p>
<p>注意，对 <code>CommonModule</code> 的引用和 <code>declarations</code> 数组不是必要的，因此它们不再是 <code>AppRoutingModule</code> 的一部分。以下各节将详细介绍 <code>AppRoutingModule</code> 的其余部分。</p>
<h3 id="5-1-1-路由"><a href="#5-1-1-路由" class="headerlink" title="5.1.1 路由"></a>5.1.1 路由</h3><p>该文件的下一部分是的路由配置。<em>Routes</em> 告诉路由器，当用户单击链接或将 URL 粘贴进浏览器地址栏时要显示哪个视图。</p>
<p>由于 <code>app-routing.module.ts</code> 已经导入了 <code>HeroesComponent</code>，因此可以直接在 <code>routes</code> 数组中使用它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> routes: Routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;heroes&#x27;</span>, <span class="hljs-attr">component</span>: HeroesComponent &#125;<br>];<br></code></pre></div></td></tr></table></figure>

<p>典型的 Angular <code>Route</code> 具有两个属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>用来匹配浏览器地址栏中 URL 的字符串。</td>
</tr>
<tr>
<td><code>component</code></td>
<td>导航到该路由时，路由器应该创建的组件。</td>
</tr>
</tbody></table>
<p>这会告诉路由器把该 URL 与 <code>path：&#39;heroes&#39;</code> 匹配。如果网址类似于 <code>localhost:4200/heroes</code> 就显示 <code>HeroesComponent</code>。</p>
<h3 id="5-1-2-RouterModule-forRoot"><a href="#5-1-2-RouterModule-forRoot" class="headerlink" title="5.1.2 RouterModule.forRoot()"></a>5.1.2 <code>RouterModule.forRoot()</code></h3><p><code>@NgModule</code> 元数据会初始化路由器，并开始监听浏览器地址的变化。</p>
<p>下面的代码行将 <code>RouterModule</code> 添加到 <code>AppRoutingModule</code> 的 <code>imports</code> 数组中，同时通过调用 <code>RouterModule.forRoot()</code> 来用这些 <code>routes</code> 配置它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">imports: [ RouterModule.forRoot(routes) ],<br></code></pre></div></td></tr></table></figure>

<p>这个方法之所以叫 <code>forRoot()</code>，是因为要在应用的顶层配置这个路由器。<code>forRoot()</code> 方法会提供路由所需的服务提供者和指令，还会基于浏览器的当前 URL 执行首次导航。</p>
<p>接下来，<code>AppRoutingModule</code> 导出 <code>RouterModule</code>，以便它在整个应用程序中生效。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-built_in">exports</span>: [ RouterModule ]<br></code></pre></div></td></tr></table></figure>



<h2 id="5-2-添加RouterOutlet"><a href="#5-2-添加RouterOutlet" class="headerlink" title="5.2 添加RouterOutlet"></a>5.2 添加RouterOutlet</h2><p>打开 <code>AppComponent</code> 的模板，把 <code>&lt;app-heroes&gt;</code> 元素替换为 <code>&lt;router-outlet&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-messages</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-messages</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><code>AppComponent</code> 的模板不再需要 <code>&lt;app-heroes&gt;</code>，因为只有当用户导航到这里时，才需要显示 <code>HeroesComponent</code>。</p>
<p><code>&lt;router-outlet&gt;</code> 会告诉路由器要在哪里显示路由的视图。</p>
<p>能在 <code>AppComponent</code> 中使用 <code>RouterOutlet</code>，是因为 <code>AppModule</code> 导入了 <code>AppRoutingModule</code>，而 <code>AppRoutingModule</code> 中导出了 <code>RouterModule</code>。在本教程开始时运行的那个 <code>ng generate</code> 命令添加了这个导入，是因为 <code>--module=app</code> 标志。如果手动创建 <code>app-routing.module.ts</code> 或使用了 CLI 之外的工具，就要把 <code>AppRoutingModule</code> 导入到 <code>app.module.ts</code> 中，并且把它添加到 <code>NgModule</code> 的 <code>imports</code> 数组中。</p>
<p>CLI 命令应该仍在运行。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ng serve</span><br></code></pre></div></td></tr></table></figure>

<p>浏览器应该刷新，并显示着应用的标题，但是没有显示英雄列表。</p>
<p>看看浏览器的地址栏。URL 是以 <code>/</code> 结尾的。而到 <code>HeroesComponent</code> 的路由路径是 <code>/heroes</code>。</p>
<p>在地址栏中把 <code>/heroes</code> 追加到 URL 后面。应该能看到熟悉的主从结构的英雄显示界面。</p>
<p>从浏览器地址栏中的 URL 中移除 <code>/heroes</code>。浏览器就会刷新，并且显示本应用的标题，而不显示英雄列表。</p>
<h2 id="5-3-添加路由链接"><a href="#5-3-添加路由链接" class="headerlink" title="5.3 添加路由链接"></a>5.3 添加路由链接</h2><p>理想情况下，用户应该能通过点击链接进行导航，而不用被迫把路由的 URL 粘贴到地址栏。</p>
<p>添加一个 <code>&lt;nav&gt;</code> 元素，并在其中放一个链接 <code>&lt;a&gt;</code> 元素，当点击它时，就会触发一个到 <code>HeroesComponent</code> 的导航。修改过的 <code>AppComponent</code> 模板如下：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/heroes&quot;</span>&gt;</span>Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-messages</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-messages</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt5#routerlink"><code>routerLink</code> 属性</a>的值为 <code>&quot;/heroes&quot;</code>，路由器会用它来匹配出指向 <code>HeroesComponent</code> 的路由。 <code>routerLink</code> 是 <a target="_blank" rel="noopener" href="https://angular.cn/api/router/RouterLink"><code>RouterLink</code> 指令</a>的选择器，它会把用户的点击转换为路由器的导航操作。 它是 <code>RouterModule</code> 中的另一个公共指令。</p>
<p>刷新浏览器，显示出了应用的标题和指向英雄列表的链接，但并没有显示英雄列表。</p>
<p>点击这个链接。地址栏变成了 <code>/heroes</code>，并且显示出了英雄列表。</p>
<h2 id="5-4-添加仪表盘视图"><a href="#5-4-添加仪表盘视图" class="headerlink" title="5.4 添加仪表盘视图"></a>5.4 添加仪表盘视图</h2><p>当有多个视图时，路由会更有价值。不过目前还只有一个英雄列表视图。</p>
<p>使用 CLI 添加一个 <code>DashboardComponent</code>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> component dashboard<br></code></pre></div></td></tr></table></figure>

<p>CLI 生成了 <code>DashboardComponent</code> 的相关文件，并把它声明到 <code>AppModule</code> 中。</p>
<p>把这三个文件中的内容改成这样：</p>
<p><code>src/app/dashboard/dashboard.component.html</code></p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Top Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes-menu&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>    &#123;&#123;hero.name&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><code>src/app/dashboard/dashboard.component.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; HeroService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero.service&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-dashboard&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./dashboard.component.html&#x27;</span>,<br>  styleUrls: [ <span class="hljs-string">&#x27;./dashboard.component.css&#x27;</span> ]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br>  heroes: Hero[] = [];<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroService</span>)</span> &#123; &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.getHeroes();<br>  &#125;<br><br>  getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.heroService.getHeroes()<br>      .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes.slice(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>));<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>src/app/dashboard/dashboard.component.css</code></p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* DashboardComponent&#x27;s private CSS styles */</span><br><br><span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.heroes-menu</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>;<br><br>  <span class="hljs-comment">/* flexbox */</span><br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>  <span class="hljs-attribute">align-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: flex-start;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3f525c</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">70px</span>;<br>  <span class="hljs-attribute">margin</span>: .<span class="hljs-number">5rem</span> auto;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br><br>  <span class="hljs-comment">/* flexbox */</span><br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> auto;<br>  <span class="hljs-attribute">align-self</span>: auto;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>) &#123;<br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">18%</span>;<br>    <span class="hljs-attribute">box-sizing</span>: content-box;<br>  &#125;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这个<em>模板</em>用来表示由英雄名字链接组成的一个阵列。</p>
<ul>
<li><code>*ngFor</code> 复写器为组件的 <code>heroes</code> 数组中的每个条目创建了一个链接。</li>
<li>这些链接被 <code>dashboard.component.css</code> 中的样式格式化成了一些色块。</li>
<li>这些链接还没有指向任何地方，但<a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt5#hero-details">很快就会了</a>。</li>
</ul>
<p>这个<em>类</em>和 <code>HeroesComponent</code> 类很像。</p>
<ul>
<li>它定义了一个 <code>heroes</code> 数组属性。</li>
<li>它的构造函数希望 Angular 把 <code>HeroService</code> 注入到私有的 <code>heroService</code> 属性中。</li>
<li>在 <code>ngOnInit()</code> 生命周期钩子中调用 <code>getHeroes()</code>。</li>
</ul>
<p>这个 <code>getHeroes()</code> 函数会截取第 2 到 第 5 位英雄，也就是说只返回四个顶层英雄（第二，第三，第四和第五）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.heroService.getHeroes()<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes.slice(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="5-4-1-添加仪表盘路由"><a href="#5-4-1-添加仪表盘路由" class="headerlink" title="5.4.1 添加仪表盘路由"></a>5.4.1 添加仪表盘路由</h3><p>要导航到仪表盘，路由器中就需要一个相应的路由。</p>
<p>把 <code>DashboardComponent</code> 导入到 <code>app-routing-module.ts</code> 中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; DashboardComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dashboard/dashboard.component&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>把一个指向 <code>DashboardComponent</code> 的路由添加到 <code>routes</code> 数组中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;dashboard&#x27;</span>, <span class="hljs-attr">component</span>: DashboardComponent &#125;,<br></code></pre></div></td></tr></table></figure>



<h3 id="5-4-2-添加默认路由"><a href="#5-4-2-添加默认路由" class="headerlink" title="5.4.2 添加默认路由"></a>5.4.2 添加默认路由</h3><p>当应用启动时，浏览器的地址栏指向了网站的根路径。它没有匹配到任何现存路由，因此路由器也不会导航到任何地方。<code>&lt;router-outlet&gt;</code> 下方是空白的。</p>
<p>要让应用自动导航到这个仪表盘，请把下列路由添加到 <code>routes</code> 数组中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>, <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">&#x27;full&#x27;</span> &#125;,<br></code></pre></div></td></tr></table></figure>

<p>这个路由会把一个与空路径“完全匹配”的 URL 重定向到路径为 <code>&#39;/dashboard&#39;</code> 的路由。</p>
<p>浏览器刷新之后，路由器加载了 <code>DashboardComponent</code>，并且浏览器的地址栏会显示出 <code>/dashboard</code> 这个 URL。</p>
<h3 id="5-4-3-把仪表盘链接添加到壳组件中"><a href="#5-4-3-把仪表盘链接添加到壳组件中" class="headerlink" title="5.4.3 把仪表盘链接添加到壳组件中"></a>5.4.3 把仪表盘链接添加到壳组件中</h3><p>应该允许用户通过点击页面顶部导航区的各个链接在 <code>DashboardComponent</code> 和 <code>HeroesComponent</code> 之间来回导航。</p>
<p>把仪表盘的导航链接添加到壳组件 <code>AppComponent</code> 的模板中，就放在 <em>Heroes</em> 链接的前面。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/heroes&quot;</span>&gt;</span>Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app-messages</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-messages</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>刷新浏览器，就能通过点击这些链接在这两个视图之间自由导航了。</p>
<h2 id="5-5-导航到英雄详情"><a href="#5-5-导航到英雄详情" class="headerlink" title="5.5 导航到英雄详情"></a>5.5 导航到英雄详情</h2><p><code>HeroDetailComponent</code> 可以显示所选英雄的详情。此刻，<code>HeroDetailComponent</code> 只能在 <code>HeroesComponent</code> 的底部看到。</p>
<p>用户应该能通过三种途径看到这些详情。</p>
<ol>
<li>通过在仪表盘中点击某个英雄。</li>
<li>通过在英雄列表中点击某个英雄。</li>
<li>通过把一个“深链接” URL 粘贴到浏览器的地址栏中来指定要显示的英雄。</li>
</ol>
<p>在这一节，将能导航到 <code>HeroDetailComponent</code>，并把它从 <code>HeroesComponent</code> 中解放出来。</p>
<h3 id="5-5-1-从HeroesComponent中删除英雄详情"><a href="#5-5-1-从HeroesComponent中删除英雄详情" class="headerlink" title="5.5.1 从HeroesComponent中删除英雄详情"></a>5.5.1 从HeroesComponent中删除英雄详情</h3><p>当用户在 <code>HeroesComponent</code> 中点击某个英雄条目时，应用应该能导航到 <code>HeroDetailComponent</code>，从英雄列表视图切换到英雄详情视图。英雄列表视图将不再显示，而英雄详情视图要显示出来。</p>
<p>打开 <code>HeroesComponent</code> 的模板文件（<code>heroes/heroes.component.html</code>），并从底部删除 <code>&lt;app-hero-detail&gt;</code> 元素。</p>
<p>目前，点击某个英雄条目还没有反应。不过当启用了到 <code>HeroDetailComponent</code> 的路由之后，很快就能修复它。</p>
<h3 id="5-5-2-添加英雄详情视图"><a href="#5-5-2-添加英雄详情视图" class="headerlink" title="5.5.2 添加英雄详情视图"></a>5.5.2 添加英雄详情视图</h3><p>要导航到 <code>id</code> 为 <code>11</code> 的英雄的<em>详情</em>视图，类似于 <code>~/detail/11</code> 的 URL 将是一个不错的 URL。</p>
<p>打开 <code>app-routing.module.ts</code> 并导入 <code>HeroDetailComponent</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HeroDetailComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero-detail/hero-detail.component&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>然后把一个<em>参数化</em>路由添加到 <code>routes</code> 数组中，它要匹配指向<em>英雄详情</em>视图的路径。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;detail/:id&#x27;</span>, <span class="hljs-attr">component</span>: HeroDetailComponent &#125;,<br></code></pre></div></td></tr></table></figure>

<p><code>path</code> 中的冒号（<code>:</code>）表示 <code>:id</code> 是一个占位符，它表示某个特定英雄的 <code>id</code>。</p>
<p>此刻，应用中的所有路由都就绪了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> routes: Routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>, <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">&#x27;full&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;dashboard&#x27;</span>, <span class="hljs-attr">component</span>: DashboardComponent &#125;,<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;detail/:id&#x27;</span>, <span class="hljs-attr">component</span>: HeroDetailComponent &#125;,<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;heroes&#x27;</span>, <span class="hljs-attr">component</span>: HeroesComponent &#125;<br>];<br></code></pre></div></td></tr></table></figure>



<h3 id="5-5-3-DashboardComponent中的英雄链接"><a href="#5-5-3-DashboardComponent中的英雄链接" class="headerlink" title="5.5.3 DashboardComponent中的英雄链接"></a>5.5.3 DashboardComponent中的英雄链接</h3><p>此刻，<code>DashboardComponent</code> 中的英雄连接还没有反应。</p>
<p>路由器已经有一个指向 <code>HeroDetailComponent</code> 的路由了，修改仪表盘中的英雄连接，让它们通过参数化的英雄详情路由进行导航。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/detail/&#123;&#123;hero.id&#125;&#125;&quot;</span>&gt;</span><br>  &#123;&#123;hero.name&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>正在 <code>*ngFor</code> 复写器中使用 Angular 的<a target="_blank" rel="noopener" href="https://angular.cn/guide/interpolation">插值绑定</a>来把当前迭代的 <code>hero.id</code> 插入到每个routerLink中。</p>
<h3 id="5-5-4-HeroesComponent中的英雄链接"><a href="#5-5-4-HeroesComponent中的英雄链接" class="headerlink" title="5.5.4 HeroesComponent中的英雄链接"></a>5.5.4 HeroesComponent中的英雄链接</h3><p><code>HeroesComponent</code> 中的这些英雄条目都是 <code>&lt;li&gt;</code> 元素，它们的点击事件都绑定到了组件的 <code>onSelect()</code> 方法中。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;onSelect(hero)&quot;</span> [<span class="hljs-attr">class.selected</span>]=<span class="hljs-string">&quot;hero === selectedHero&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>清理 <code>&lt;li&gt;</code>，只保留它的 <code>*ngFor</code>，把徽章（<code>&lt;badge&gt;</code>）和名字包裹进一个 <code>&lt;a&gt;</code> 元素中， 并且像仪表盘的模板中那样为这个 <code>&lt;a&gt;</code> 元素添加一个 <code>routerLink</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/detail/&#123;&#123;hero.id&#125;&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> &#123;&#123;hero.name&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>还要修改私有样式表（<code>heroes.component.css</code>），让列表恢复到以前的外观。</p>
<h4 id="5-5-4-1-移除死代码（可选）"><a href="#5-5-4-1-移除死代码（可选）" class="headerlink" title="5.5.4.1 移除死代码（可选）"></a>5.5.4.1 移除死代码（可选）</h4><p>虽然 <code>HeroesComponent</code> 类仍然能正常工作，但 <code>onSelect()</code> 方法和 <code>selectedHero</code> 属性已经没用了。</p>
<p>最好清理掉它们，将来会体会到这么做的好处。下面是删除了死代码之后的类。</p>
<p><code>src/app/heroes/heroes.component.ts (cleaned up)  </code></p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroesComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br>  heroes: Hero[] = [];<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroService</span>)</span> &#123; &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.getHeroes();<br>  &#125;<br><br>  getHeroes(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.heroService.getHeroes()<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-built_in">this</span>.heroes = heroes);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="5-6-支持路由的HeroDetailComponent"><a href="#5-6-支持路由的HeroDetailComponent" class="headerlink" title="5.6 支持路由的HeroDetailComponent"></a>5.6 支持路由的HeroDetailComponent</h2><p>以前，父组件 <code>HeroesComponent</code> 会设置 <code>HeroDetailComponent.hero</code> 属性，然后 <code>HeroDetailComponent</code> 就会显示这个英雄。</p>
<p><code>HeroesComponent</code> 已经不会再那么做了。现在，当路由器会在响应形如 <code>~/detail/11</code> 的 URL 时创建 <code>HeroDetailComponent</code>。</p>
<p><code>HeroDetailComponent</code> 需要从一种新的途径获取<em>要显示的英雄</em>。本节会讲解如下操作：</p>
<ul>
<li>获取创建本组件的路由</li>
<li>从这个路由中提取出 <code>id</code></li>
<li>通过 <code>HeroService</code> 从服务器上获取具有这个 <code>id</code> 的英雄数据。</li>
</ul>
<p>先添加下列导入语句：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ActivatedRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Location &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123; HeroService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero.service&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>然后把 <code>ActivatedRoute</code>、<code>HeroService</code> 和 <code>Location</code> 服务注入到构造函数中，将它们的值保存到私有变量里：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-keyword">private</span> route: ActivatedRoute,</span><br><span class="hljs-params">  <span class="hljs-keyword">private</span> heroService: HeroService,</span><br><span class="hljs-params">  <span class="hljs-keyword">private</span> location: Location</span><br><span class="hljs-params"></span>) &#123;&#125;<br></code></pre></div></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://angular.cn/api/router/ActivatedRoute"><code>ActivatedRoute</code></a> 保存着到这个 <code>HeroDetailComponent</code> 实例的路由信息。这个组件对从 URL 中提取的路由参数感兴趣。其中的 <code>id</code> 参数就是要显示的英雄的 <code>id</code>。</p>
<p><a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt4"><code>HeroService</code></a> 从远端服务器获取英雄数据，本组件将使用它来获取要显示的英雄。</p>
<p><a target="_blank" rel="noopener" href="https://angular.cn/api/common/Location"><code>location</code></a> 是一个 Angular 的服务，用来与浏览器打交道。稍后，就会使用它来导航回上一个视图。</p>
<h3 id="5-6-1-从路由参数中提取id"><a href="#5-6-1-从路由参数中提取id" class="headerlink" title="5.6.1 从路由参数中提取id"></a>5.6.1 从路由参数中提取id</h3><p>在 <code>ngOnInit()</code> <a target="_blank" rel="noopener" href="https://angular.cn/guide/lifecycle-hooks#oninit">生命周期钩子</a> 中调用 <code>getHero()</code>，代码如下。</p>
<p><code>src/app/hero-detail/hero-detail.component.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.getHero();<br>&#125;<br><br>getHero(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">this</span>.route.snapshot.paramMap.get(<span class="hljs-string">&#x27;id&#x27;</span>));<br>  <span class="hljs-built_in">this</span>.heroService.getHero(id)<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> <span class="hljs-built_in">this</span>.hero = hero);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>route.snapshot</code> 是一个路由信息的静态快照，抓取自组件刚刚创建完毕之后。</p>
<p><code>paramMap</code> 是一个从 URL 中提取的路由参数值的字典。<code>&quot;id&quot;</code> 对应的值就是要获取的英雄的 <code>id</code>。</p>
<p>路由参数总会是字符串。JavaScript 的 <code>Number</code> 函数会把字符串转换成数字，英雄的 <code>id</code> 就是数字类型。</p>
<p>刷新浏览器，应用挂了。出现一个编译错误，因为 <code>HeroService</code> 没有一个名叫 <code>getHero()</code> 的方法。这就添加它。</p>
<h3 id="5-6-2-添加-HeroService-getHero"><a href="#5-6-2-添加-HeroService-getHero" class="headerlink" title="5.6.2 添加 HeroService.getHero()"></a>5.6.2 添加 <code>HeroService.getHero()</code></h3><p>添加 <code>HeroService</code>，并在 <code>getHeroes()</code> 后面添加如下的 <code>getHero()</code> 方法，它接收 <code>id</code> 参数：</p>
<p><code>src/app/hero.service.ts (getHero)</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objectivec">getHero(<span class="hljs-keyword">id</span>: number): Observable&lt;Hero&gt; &#123;<br>  <span class="hljs-comment">// For now, assume that a hero with the specified `id` always exists.</span><br>  <span class="hljs-comment">// Error handling will be added in the next step of the tutorial.</span><br>  <span class="hljs-keyword">const</span> hero = HEROES.find(h =&gt; h.id === <span class="hljs-keyword">id</span>)!;<br>  <span class="hljs-keyword">this</span>.messageService.add(`HeroService: fetched hero <span class="hljs-keyword">id</span>=$&#123;<span class="hljs-keyword">id</span>&#125;`);<br>  <span class="hljs-keyword">return</span> of(hero);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>反引号 ( ` ) 用于定义 JavaScript 的模板字符串字面量以便嵌入 id。</p>
<p>像<code>getHeroes()</code>一样，<code>getHero()</code> 也有一个异步函数签名。它用 RxJS 的 <code>of()</code> 函数返回一个 <code>Observable</code> 形式的<em>模拟英雄数据</em>。</p>
<p>将来可以用一个真实的 <code>Http</code> 请求来重新实现 <code>getHero()</code>，而不用修改调用了它的 <code>HeroDetailComponent</code>。</p>
<p>刷新浏览器，应用又恢复正常了。可以在仪表盘或英雄列表中点击一个英雄来导航到该英雄的详情视图。</p>
<p>如果在浏览器的地址栏中粘贴了 <code>localhost:4200/detail/11</code>，路由器也会导航到 <code>id: 11</code> 的英雄（”Dr. Nice”）的详情视图。</p>
<h3 id="5-6-3-回到原路"><a href="#5-6-3-回到原路" class="headerlink" title="5.6.3 回到原路"></a>5.6.3 回到原路</h3><p>通过点击浏览器的后退按钮，可以回到英雄列表或仪表盘视图，这取决于从哪里进入的详情视图。</p>
<p>如果能在 <code>HeroDetail</code> 视图中也有这么一个按钮就更好了。</p>
<p>把一个<em>后退</em>按钮添加到组件模板的底部，并且把它绑定到组件的 <code>goBack()</code> 方法。</p>
<p><code>src/app/hero-detail/hero-detail.component.html (back button)</code></p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;goBack()&quot;</span>&gt;</span>go back<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>在组件类中添加一个 <code>goBack()</code> 方法，利用以前注入的<code>Location</code> 服务在浏览器的历史栈中后退一步。</p>
<p><code>src/app/hero-detail/hero-detail.component.ts (goBack)</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">goBack(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.location.back();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>刷新浏览器，并开始点击。用户能在应用中导航：从仪表盘到英雄详情再回来，从英雄列表到 mini 版英雄详情到英雄详情，再回到英雄列表。</p>
<p>当将一些私有 CSS 样式添加到 <code>hero-detail.component.css</code> 里之后，其细节看起来会更好。</p>
<h2 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h2><ul>
<li>添加了 Angular <em>路由器</em>在各个不同组件之间导航</li>
<li>使用一些 <code>&lt;a&gt;</code> 链接和一个 <code>&lt;router-outlet&gt;</code> 把 <code>AppComponent</code> 转换成了一个导航用的壳组件</li>
<li>在 <code>AppRoutingModule</code> 中配置了路由器</li>
<li>定义了一些简单路由、一个重定向路由和一个参数化路由</li>
<li>在 <code>&lt;a&gt;</code> 元素中使用了 <code>routerLink</code> 指令</li>
<li>把一个紧耦合的主从视图重构成了带路由的详情视图</li>
<li>使用路由链接参数来导航到所选英雄的详情视图</li>
<li>在多个组件之间共享了 <code>HeroService</code> 服务</li>
</ul>
<h1 id="6-从服务端获取数据"><a href="#6-从服务端获取数据" class="headerlink" title="6 从服务端获取数据"></a>6 从服务端获取数据</h1><p>在这节课中，将借助 Angular 的 <code>HttpClient</code> 来添加一些数据持久化特性。</p>
<ul>
<li><code>HeroService</code> 通过 HTTP 请求获取英雄数据</li>
<li>用户可以添加、编辑和删除英雄，并通过 HTTP 来保存这些更改</li>
<li>用户可以根据名字搜索英雄</li>
</ul>
<h2 id="6-1-启用-HTTP-服务"><a href="#6-1-启用-HTTP-服务" class="headerlink" title="6.1 启用 HTTP 服务"></a>6.1 启用 HTTP 服务</h2><p><code>HttpClient</code> 是 Angular 通过 HTTP 与远程服务器通讯的机制。</p>
<p>要让 <code>HttpClient</code> 在应用中随处可用，需要两个步骤。首先，用导入语句把它添加到根模块 <code>AppModule</code> 中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HttpClientModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>接下来，仍然在 <code>AppModule</code> 中，把 <code>HttpClientModule</code> 添加到 <code>imports</code> 数组中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@NgModule</span>(&#123;<br>  imports: [<br>    HttpClientModule,<br>  ],<br>&#125;)<br></code></pre></div></td></tr></table></figure>



<h2 id="6-2-模拟数据服务器"><a href="#6-2-模拟数据服务器" class="headerlink" title="6.2 模拟数据服务器"></a>6.2 模拟数据服务器</h2><p>这个教学例子会与一个使用 <a target="_blank" rel="noopener" href="https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api">内存 Web API（<em>In-memory Web API</em>）</a> 模拟出的远程数据服务器通讯。</p>
<p>安装完这个模块之后，应用将会通过 <code>HttpClient</code> 来发起请求和接收响应，而不用在乎实际上是这个内存 Web API 在拦截这些请求、操作一个内存数据库，并且给出仿真的响应。</p>
<p>通过使用内存 Web API，不用架设服务器就可以学习 <code>HttpClient</code> 了。</p>
<p><strong>重要</strong>：<br>这个<em>内存 Web API</em> 模块与 Angular 中的 HTTP 模块无关。</p>
<p>如果只是在<em>阅读</em>本教程来学习 <code>HttpClient</code>，那么可以跳过这一步。 如果正在随着本教程<em>敲代码</em>，那就留下来，并加上这个<em>内存 Web API</em>。</p>
<p>用如下命令从 <code>npm</code> 中安装这个<em>内存 Web API</em> 包（译注：请使用 0.5+ 的版本，不要使用 0.4-）</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">npm install angular-<span class="hljs-keyword">in</span>-<span class="hljs-keyword">memory</span>-web-api --<span class="hljs-keyword">save</span><br></code></pre></div></td></tr></table></figure>

<p>在 <code>AppModule</code> 中，导入 <code>HttpClientInMemoryWebApiModule</code> 和 <code>InMemoryDataService</code> 类，稍后将创建它们。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HttpClientInMemoryWebApiModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;angular-in-memory-web-api&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; InMemoryDataService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./in-memory-data.service&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>在 <code>HttpClientModule</code> 之后，将 <code>HttpClientInMemoryWebApiModule</code> 添加到 <code>AppModule</code> 的 <code>imports</code> 数组中，并以 <code>InMemoryDataService</code> 为参数对其进行配置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">HttpClientModule,<br><br><span class="hljs-comment">// The HttpClientInMemoryWebApiModule module intercepts HTTP requests</span><br><span class="hljs-comment">// and returns simulated server responses.</span><br><span class="hljs-comment">// Remove it when a real server is ready to receive requests.</span><br>HttpClientInMemoryWebApiModule.forRoot(<br>  InMemoryDataService, &#123; <span class="hljs-attr">dataEncapsulation</span>: <span class="hljs-literal">false</span> &#125;<br>)<br></code></pre></div></td></tr></table></figure>

<p><code>forRoot()</code> 配置方法接收一个 <code>InMemoryDataService</code> 类来初始化内存数据库。</p>
<p>使用以下命令生成类 <code>src/app/in-memory-data.service.ts</code>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> service InMemoryData<br></code></pre></div></td></tr></table></figure>

<p>将 <code>in-memory-data.service.ts</code> 改为以下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; InMemoryDbService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;angular-in-memory-web-api&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hero&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>(&#123;<br>  providedIn: <span class="hljs-string">&#x27;root&#x27;</span>,<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryDataService</span> <span class="hljs-title">implements</span> <span class="hljs-title">InMemoryDbService</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">createDb</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> heroes = [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dr. Nice&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">13</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bombasto&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Celeritas&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Magneta&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RubberMan&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dynama&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dr. IQ&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">19</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Magma&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tornado&#x27;</span> &#125;<br>    ];<br>    <span class="hljs-keyword">return</span> &#123;heroes&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// Overrides the genId method to ensure that a hero always has an id.</span><br>  <span class="hljs-comment">// If the heroes array is empty,</span><br>  <span class="hljs-comment">// the method below returns the initial number (11).</span><br>  <span class="hljs-comment">// if the heroes array is not empty, the method below returns the highest</span><br>  <span class="hljs-comment">// hero id + 1.</span><br>  genId(heroes: Hero[]): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> heroes.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.max(...heroes.map(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> hero.id)) + <span class="hljs-number">1</span> : <span class="hljs-number">11</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><code>in-memory-data.service.ts</code> 文件已代替了 <code>mock-heroes.ts</code> 文件，现在后者可以安全的删除了。</p>
<p>等服务器就绪后，就可以抛弃这个内存 Web API，应用的请求将直接传给服务器。</p>
<h2 id="6-3-英雄与-HTTP"><a href="#6-3-英雄与-HTTP" class="headerlink" title="6.3 英雄与 HTTP"></a>6.3 英雄与 HTTP</h2><p>在 <code>HeroService</code> 中，导入 <code>HttpClient</code> 和 <code>HttpHeaders</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; HttpClient, HttpHeaders &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>仍然在 <code>HeroService</code> 中，把 <code>HttpClient</code> 注入到构造函数中一个名叫 <code>http</code> 的私有属性中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-keyword">private</span> http: HttpClient,</span><br><span class="hljs-params">  <span class="hljs-keyword">private</span> messageService: MessageService</span>) &#123; &#125;<br></code></pre></div></td></tr></table></figure>



<p>注意保留对 <code>MessageService</code> 的注入，但是因为将频繁调用它，因此请把它包裹进一个私有的 <code>log</code> 方法中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** Log a HeroService message with the MessageService */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.messageService.add(<span class="hljs-string">`HeroService: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>把服务器上英雄数据资源的访问地址 <code>heroesURL</code> 定义为 <code>:base/:collectionName</code> 的形式。这里的 <code>base</code> 是要请求的资源，而 <code>collectionName</code> 是 <code>in-memory-data-service.ts</code> 中的英雄数据对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> heroesUrl = <span class="hljs-string">&#x27;api/heroes&#x27;</span>;  <span class="hljs-comment">// URL to web api</span><br></code></pre></div></td></tr></table></figure>





<h3 id="6-3-1-通过-HttpClient-获取英雄"><a href="#6-3-1-通过-HttpClient-获取英雄" class="headerlink" title="6.3.1 通过 HttpClient 获取英雄"></a>6.3.1 通过 <code>HttpClient</code> 获取英雄</h3><p>当前的 <code>HeroService.getHeroes()</code> 使用 RxJS 的 <code>of()</code> 函数来把模拟英雄数据返回为 <code>Observable&lt;Hero[]&gt;</code> 格式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">const</span> heroes = <span class="hljs-keyword">of</span>(HEROES);<br>  <span class="hljs-keyword">return</span> heroes;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>把该方法转换成使用 <code>HttpClient</code> 的，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** GET heroes from the server */</span><br>getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-built_in">this</span>.heroesUrl)<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>刷新浏览器后，英雄数据就会从模拟服务器被成功读取。</p>
<p>用 <code>http.get()</code> 替换了 <code>of()</code>，没有做其它修改，但是应用仍然在正常工作，这是因为这两个函数都返回了 <code>Observable&lt;Hero[]&gt;</code>。</p>
<h3 id="6-3-2-HttpClient的方法返回单个值"><a href="#6-3-2-HttpClient的方法返回单个值" class="headerlink" title="6.3.2 HttpClient的方法返回单个值"></a>6.3.2 HttpClient的方法返回单个值</h3><p>所有的 <code>HttpClient</code> 方法都会返回某个值的 RxJS <code>Observable</code>。</p>
<p>HTTP 是一个请求/响应式协议。发起请求，它返回单个的响应。</p>
<p>通常，<code>Observable</code> <em>可以</em>在一段时间内返回多个值。但来自 <code>HttpClient</code> 的 <code>Observable</code> 总是发出一个值，然后结束，再也不会发出其它值。</p>
<p>具体到这次 <code>HttpClient.get()</code> 调用，它返回一个 <code>Observable&lt;Hero[]&gt;</code>，也就是“一个英雄数组的可观察对象”。在实践中，它也只会返回一个英雄数组。</p>
<h3 id="6-3-3-HttpClient-get-返回响应数据"><a href="#6-3-3-HttpClient-get-返回响应数据" class="headerlink" title="6.3.3 HttpClient.get() 返回响应数据"></a>6.3.3 <code>HttpClient.get()</code> 返回响应数据</h3><p><code>HttpClient.get()</code> 默认情况下把响应体当做无类型的 JSON 对象进行返回。如果指定了可选的模板类型 <code>&lt;Hero[]&gt;</code>，就会给返回一个类型化的对象。</p>
<p>服务器的数据 API 决定了 JSON 数据的具体形态。<em>英雄之旅</em>的数据 API 会把英雄数据作为一个数组进行返回。</p>
<p>其它 API 可能在返回对象中深埋着想要的数据。可能要借助 RxJS 的 <code>map()</code> 操作符对 <code>Observable</code> 的结果进行处理，以便把这些数据挖掘出来。</p>
<p>虽然不打算在此展开讨论，不过可以到范例源码中的 <code>getHeroNo404()</code> 方法中找到一个使用 <code>map()</code> 操作符的例子。</p>
<h3 id="6-3-4-错误处理"><a href="#6-3-4-错误处理" class="headerlink" title="6.3.4 错误处理"></a>6.3.4 错误处理</h3><p>凡事皆会出错，特别是当从远端服务器获取数据的时候。<code>HeroService.getHeroes()</code> 方法应该捕获错误，并做适当的处理。</p>
<p>要捕获错误，就要使用 RxJS 的 <code>catchError()</code> 操作符来<strong>建立对 Observable 结果的处理管道（pipe）</strong>。</p>
<p>从 <code>rxjs/operators</code> 中导入 <code>catchError</code> 符号，以及稍后将会用到的其它操作符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; catchError, map, tap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br></code></pre></div></td></tr></table></figure>



<p>现在，使用 <code>pipe()</code> 方法来扩展 <code>Observable</code> 的结果，并给它一个 <code>catchError()</code> 操作符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-built_in">this</span>.heroesUrl)<br>    .pipe(<br>      catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">&#x27;getHeroes&#x27;</span>, []))<br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><code>catchError()</code> 操作符会拦截<strong>失败的 Observable</strong>。它把错误对象传给<em>错误处理器</em>，<em>错误处理器</em>会处理这个错误。</p>
<p>下面的 <code>handleError()</code> 方法会报告这个错误，并返回一个无害的结果（安全值），以便应用能正常工作。</p>
<h4 id="6-3-4-1-handleError"><a href="#6-3-4-1-handleError" class="headerlink" title="6.3.4.1 handleError"></a>6.3.4.1 <code>handleError</code></h4><p>下面这个 <code>handleError()</code> 将会在很多 <code>HeroService</code> 的方法之间共享，所以要把它通用化，以支持这些彼此不同的需求。</p>
<p>它不再直接处理这些错误，而是返回给 <code>catchError</code> 返回一个错误处理函数。还要用操作名和出错时要返回的安全值来对这个错误处理函数进行配置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handle Http operation that failed.</span><br><span class="hljs-comment"> * Let the app continue.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">operation</span></span> - name of the operation that failed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">result</span></span> - optional value to return as the observable result</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> handleError&lt;T&gt;(operation = <span class="hljs-string">&#x27;operation&#x27;</span>, result?: T) &#123;<br>  <span class="hljs-keyword">return</span> (error: <span class="hljs-built_in">any</span>): Observable&lt;T&gt; =&gt; &#123;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send the error to remote logging infrastructure</span><br>    <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// log to console instead</span><br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> better job of transforming error for user consumption</span><br>    <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;operation&#125;</span> failed: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br><br>    <span class="hljs-comment">// Let the app keep running by returning an empty result.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>(result <span class="hljs-keyword">as</span> T);<br>  &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>在控制台中汇报了这个错误之后，这个处理器会汇报一个用户友好的消息，并给应用返回一个安全值，让应用继续工作。</p>
<p>因为每个服务方法都会返回不同类型的 <code>Observable</code> 结果，因此 <code>handleError()</code> 也需要一个类型参数，以便它返回一个此类型的安全值，正如应用所期望的那样。</p>
<h3 id="6-3-5-窥探-Observable"><a href="#6-3-5-窥探-Observable" class="headerlink" title="6.3.5 窥探 Observable"></a>6.3.5 窥探 <code>Observable</code></h3><p><code>HeroService</code> 的方法将会窥探 <code>Observable</code> 的数据流，并通过 <code>log()</code> 方法往页面底部发送一条消息。</p>
<p>它们可以使用 RxJS 的 <code>tap()</code> 操作符来实现，该操作符会查看 Observable 中的值，使用那些值做一些事情，并且把它们传出来。这种 <code>tap()</code> 回调不会改变这些值本身。</p>
<p>下面是 <code>getHeroes()</code> 的最终版本，它使用 <code>tap()</code> 来记录各种操作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** GET heroes from the server */</span><br>getHeroes(): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-built_in">this</span>.heroesUrl)<br>    .pipe(<br>      tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">&#x27;fetched heroes&#x27;</span>)),<br>      catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">&#x27;getHeroes&#x27;</span>, []))<br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="6-3-6-通过-id-获取英雄"><a href="#6-3-6-通过-id-获取英雄" class="headerlink" title="6.3.6 通过 id 获取英雄"></a>6.3.6 通过 id 获取英雄</h3><p>大多数的 Web API 都支持以 <code>:baseURL/:id</code> 的形式根据 id 进行获取。</p>
<p>这里的 <code>baseURL</code> 就是在 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt6#heroes-and-http">英雄列表与 HTTP</a> 部分定义过的 <code>heroesURL</code>（<code>api/heroes</code>）。而 <code>id</code> 则是要获取的英雄的编号，比如，<code>api/heroes/11</code>。</p>
<p>把 <code>HeroService.getHero()</code> 方法改成这样，以发起该请求：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** GET hero by id. Will 404 if id not found */</span><br>getHero(id: <span class="hljs-built_in">number</span>): Observable&lt;Hero&gt; &#123;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.heroesUrl&#125;</span>/<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero&gt;(url).pipe(<br>    tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`fetched hero id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>)),<br>    catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">`getHero id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>))<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>这里和 <code>getHeroes()</code> 相比有三个显著的差异:</p>
<ul>
<li><code>getHero()</code> 使用想获取的英雄的 id 构造了一个请求 URL</li>
<li>服务器应该使用单个英雄作为回应，而不是一个英雄数组</li>
<li>所以，<code>getHero()</code> 会返回 <code>Observable&lt;Hero&gt;</code>（“一个可观察的<em>单个英雄对象</em>”），而不是一个可观察的英雄对象<em>数组</em></li>
</ul>
<h2 id="6-4-修改英雄"><a href="#6-4-修改英雄" class="headerlink" title="6.4 修改英雄"></a>6.4 修改英雄</h2><p>在<em>英雄详情</em>视图中编辑英雄的名字。随着输入，英雄的名字也跟着在页面顶部的标题区更新了。但是当点击“后退”按钮时，这些修改都丢失了。</p>
<p>如果希望保留这些修改，就要把它们写回到服务器。</p>
<p>在英雄详情模板的底部添加一个保存按钮，它绑定了一个 <code>click</code> 事件，事件绑定会调用组件中一个名叫 <code>save()</code> 的新方法。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;save()&quot;</span>&gt;</span>save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<p>在 <code>HeroDetail</code> 组件类中，添加如下的 <code>save()</code> 方法，它使用英雄服务中的 <code>updateHero()</code> 方法来保存对英雄名字的修改，然后导航回前一个视图。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">save(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hero) &#123;<br>    <span class="hljs-built_in">this</span>.heroService.updateHero(<span class="hljs-built_in">this</span>.hero)<br>      .subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.goBack());<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="6-4-1-添加-HeroService-updateHero"><a href="#6-4-1-添加-HeroService-updateHero" class="headerlink" title="6.4.1 添加 HeroService.updateHero()"></a>6.4.1 添加 <code>HeroService.updateHero()</code></h3><p><code>updateHero()</code> 的总体结构和 <code>getHeroes()</code> 很相似，但它会使用 <code>http.put()</code> 来把修改后的英雄保存到服务器上。把下列代码添加进 <code>HeroService</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** PUT: update the hero on the server */</span><br>updateHero(hero: Hero): Observable&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.put(<span class="hljs-built_in">this</span>.heroesUrl, hero, <span class="hljs-built_in">this</span>.httpOptions).pipe(<br>    tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`updated hero id=<span class="hljs-subst">$&#123;hero.id&#125;</span>`</span>)),<br>    catchError(<span class="hljs-built_in">this</span>.handleError&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-string">&#x27;updateHero&#x27;</span>))<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>HttpClient.put()</code> 方法接受三个参数：</p>
<ul>
<li>URL 地址</li>
<li>要修改的数据（这里就是修改后的英雄）</li>
<li>选项</li>
</ul>
<p>URL 没变。英雄 Web API 通过英雄对象的 <code>id</code> 就可以知道要修改哪个英雄。</p>
<p>英雄 Web API 期待在保存时的请求中有一个特殊的头。这个头是在 <code>HeroService</code> 的 <code>httpOptions</code> 常量中定义的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">httpOptions = &#123;<br>  headers: <span class="hljs-keyword">new</span> HttpHeaders(&#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;)<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<p>刷新浏览器，修改英雄名，保存这些修改。在 <code>HeroDetailComponent</code> 的 <code>save()</code> 方法中导航到前一个视图。现在，改名后的英雄已经显示在列表中了。</p>
<h2 id="6-5-添加一个新英雄"><a href="#6-5-添加一个新英雄" class="headerlink" title="6.5 添加一个新英雄"></a>6.5 添加一个新英雄</h2><p>要添加英雄，本应用中只需要英雄的名字。可以使用一个和添加按钮成对的 <code>&lt;input&gt;</code> 元素。</p>
<p>把下列代码插入到 <code>HeroesComponent</code> 模板中标题的紧后面：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;new-hero&quot;</span>&gt;</span>Hero name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;new-hero&quot;</span> #<span class="hljs-attr">heroName</span> /&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- (click) passes input value to add() and then clears the input --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add-button&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;add(heroName.value); heroName.value=&#x27;&#x27;&quot;</span>&gt;</span><br>    Add hero<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<p>当点击事件触发时，调用组件的点击处理器（<code>add()</code>），然后清空这个输入框，以便用来输入另一个名字。把下列代码添加到 <code>HeroesComponent</code> 类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">add(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>  name = name.trim();<br>  <span class="hljs-keyword">if</span> (!name) &#123; <span class="hljs-keyword">return</span>; &#125;<br>  <span class="hljs-built_in">this</span>.heroService.addHero(&#123; name &#125; <span class="hljs-keyword">as</span> Hero)<br>    .subscribe(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.heroes.push(hero);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>当指定的名字非空时，这个处理器会用这个名字创建一个类似于 <code>Hero</code> 的对象（只缺少 <code>id</code> 属性），并把它传给服务的 <code>addHero()</code> 方法。</p>
<p>当 <code>addHero()</code> 保存成功时，<code>subscribe()</code> 的回调函数会收到这个新英雄，并把它追加到 <code>heroes</code> 列表中以供显示。</p>
<p>往 <code>HeroService</code> 类中添加 <code>addHero()</code> 方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** POST: add a new hero to the server */</span><br>addHero(hero: Hero): Observable&lt;Hero&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.post&lt;Hero&gt;(<span class="hljs-built_in">this</span>.heroesUrl, hero, <span class="hljs-built_in">this</span>.httpOptions).pipe(<br>    tap(<span class="hljs-function">(<span class="hljs-params">newHero: Hero</span>) =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`added hero w/ id=<span class="hljs-subst">$&#123;newHero.id&#125;</span>`</span>)),<br>    catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">&#x27;addHero&#x27;</span>))<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><code>addHero()</code> 和 <code>updateHero()</code> 有两点不同。</p>
<ul>
<li>它调用 <code>HttpClient.post()</code> 而不是 <code>put()</code>。</li>
<li>它期待服务器为这个新的英雄生成一个 id，然后把它通过 <code>Observable&lt;Hero&gt;</code> 返回给调用者。</li>
</ul>
<p>刷新浏览器，并添加一些英雄。</p>
<h2 id="6-6-删除某个英雄"><a href="#6-6-删除某个英雄" class="headerlink" title="6.6 删除某个英雄"></a>6.6 删除某个英雄</h2><p>英雄列表中的每个英雄都有一个删除按钮。</p>
<p>把下列按钮（<code>button</code>）元素添加到 <code>HeroesComponent</code> 的模板中，就在每个 <code>&lt;li&gt;</code> 元素中的英雄名字后方。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;delete hero&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;delete(hero)&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<p>英雄列表的 HTML 应该是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heroes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/detail/&#123;&#123;hero.id&#125;&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;hero.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> &#123;&#123;hero.name&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;delete hero&quot;</span></span><br><span class="hljs-tag">      (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;delete(hero)&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<p>要把删除按钮定位在每个英雄条目的最右边，就要往 <code>heroes.component.css</code> 中添加一些 CSS。可以在下方的 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt6#heroescomponent">最终代码</a> 中找到这些 CSS。</p>
<p>把 <code>delete()</code> 处理器添加到组件中。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">delete(hero: Hero): void &#123;<br>  this.heroes = this.heroes.filter(h =&gt; h !== hero);<br>  this.heroService.deleteHero(hero.id).subscribe();<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>虽然这个组件把删除英雄的逻辑委托给了 <code>HeroService</code>，但仍保留了更新它自己的英雄列表的职责。组件的 <code>delete()</code> 方法会在 <code>HeroService</code> 对服务器的操作成功之前，先从列表中移除<em>要删除的英雄</em>。</p>
<p>组件与 <code>heroService.deleteHero()</code> 返回的 <code>Observable</code> 还完全没有关联。<strong>必须订阅它</strong>。</p>
<p>如果忘了调用 <code>subscribe()</code>，本服务将不会把这个删除请求发送给服务器。作为一条通用的规则，<code>Observable</code> 在有人订阅之前<em>什么都不会做</em>。</p>
<p>可以暂时删除 <code>subscribe()</code> 来确认这一点。点击“Dashboard”，然后点击“Heroes”，就又看到完整的英雄列表了。</p>
<p>接下来，把 <code>deleteHero()</code> 方法添加到 <code>HeroService</code> 中，代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/** DELETE: delete the hero from the server */</span><br>deleteHero(id: <span class="hljs-built_in">number</span>): Observable&lt;Hero&gt; &#123;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.heroesUrl&#125;</span>/<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.delete&lt;Hero&gt;(url, <span class="hljs-built_in">this</span>.httpOptions).pipe(<br>    tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`deleted hero id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>)),<br>    catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">&#x27;deleteHero&#x27;</span>))<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>注意以下关键点：</p>
<ul>
<li><code>deleteHero()</code> 调用了 <code>HttpClient.delete()</code></li>
<li>URL 就是英雄的资源 URL 加上要删除的英雄的 <code>id</code></li>
<li>不用像 <code>put()</code> 和 <code>post()</code> 中那样发送任何数据</li>
<li>仍要发送 <code>httpOptions</code></li>
</ul>
<p>刷新浏览器，并试一下这个新的删除功能。</p>
<h2 id="6-7-根据名字搜索"><a href="#6-7-根据名字搜索" class="headerlink" title="6.7 根据名字搜索"></a>6.7 根据名字搜索</h2><p>在最后一次练习中，要学到把 <code>Observable</code> 的操作符串在一起，让能将相似 HTTP 请求的数量最小化，并节省网络带宽。</p>
<p>将往<em>仪表盘</em>中加入<em>英雄搜索</em>特性。当用户在搜索框中输入名字时，会不断发送根据名字过滤英雄的 HTTP 请求。的目标是仅仅发出尽可能少的必要请求。</p>
<p>先把 <code>searchHeroes()</code> 方法添加到 <code>HeroService</code> 中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/* GET heroes whose name contains search term */</span><br>searchHeroes(term: <span class="hljs-built_in">string</span>): Observable&lt;Hero[]&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!term.trim()) &#123;<br>    <span class="hljs-comment">// if not search term, return empty hero array.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>([]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.heroesUrl&#125;</span>/?name=<span class="hljs-subst">$&#123;term&#125;</span>`</span>).pipe(<br>    tap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.length ?<br>       <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`found heroes matching &quot;<span class="hljs-subst">$&#123;term&#125;</span>&quot;`</span>) :<br>       <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`no heroes matching &quot;<span class="hljs-subst">$&#123;term&#125;</span>&quot;`</span>)),<br>    catchError(<span class="hljs-built_in">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">&#x27;searchHeroes&#x27;</span>, []))<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>如果没有搜索词，该方法立即返回一个空数组。剩下的部分和 <code>getHeroes()</code> 很像。唯一的不同点是 URL，它包含了一个由搜索词组成的查询字符串。</p>
<h3 id="6-7-1-为仪表盘添加搜索功能"><a href="#6-7-1-为仪表盘添加搜索功能" class="headerlink" title="6.7.1 为仪表盘添加搜索功能"></a>6.7.1 为仪表盘添加搜索功能</h3><p>打开 <code>DashboardComponent</code> 的模板并且把用于搜索英雄的元素 <code>&lt;app-hero-search&gt;</code> 添加到代码的底部。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ht">&lt;h2&gt;Top Heroes&lt;&#x2F;h2&gt;<br>&lt;div class&#x3D;&quot;heroes-menu&quot;&gt;<br>  &lt;a *ngFor&#x3D;&quot;let hero of heroes&quot;<br>      routerLink&#x3D;&quot;&#x2F;detail&#x2F;&#123;&#123;hero.id&#125;&#125;&quot;&gt;<br>      &#123;&#123;hero.name&#125;&#125;<br>  &lt;&#x2F;a&gt;<br>&lt;&#x2F;div&gt;<br><br>&lt;app-hero-search&gt;&lt;&#x2F;app-hero-search&gt;<br></code></pre></div></td></tr></table></figure>

<p>这个模板看起来很像 <code>HeroesComponent</code> 模板中的 <code>*ngFor</code> 复写器。</p>
<p>为此，下一步就是添加一个组件，它的选择器要能匹配 <code>&lt;app-hero-search&gt;</code>。</p>
<h3 id="6-7-2-创建-HeroSearchComponent"><a href="#6-7-2-创建-HeroSearchComponent" class="headerlink" title="6.7.2 创建 HeroSearchComponent"></a>6.7.2 创建 <code>HeroSearchComponent</code></h3><p>使用 CLI 创建一个 <code>HeroSearchComponent</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">ng <span class="hljs-keyword">generate</span> component hero-search<br></code></pre></div></td></tr></table></figure>



<p>CLI 生成了 <code>HeroSearchComponent</code> 的三个文件，并把该组件添加到了 <code>AppModule</code> 的声明中。</p>
<p>把生成的 <code>HeroSearchComponent</code> 的<em>模板</em>改成一个 <code>&lt;input&gt;</code> 和一个匹配到的搜索结果的列表。代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search-component&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;search-box&quot;</span>&gt;</span>Hero Search<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> #<span class="hljs-attr">searchBox</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search-box&quot;</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">&quot;search(searchBox.value)&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-result&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes$ | async&quot;</span> &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/detail/&#123;&#123;hero.id&#125;&#125;&quot;</span>&gt;</span><br>        &#123;&#123;hero.name&#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>



<p>从下面的 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt6#herosearchcomponent">最终代码</a> 中把私有 CSS 样式添加到 <code>hero-search.component.css</code> 中。</p>
<p>当用户在搜索框中输入时，一个 <code>input</code> 事件绑定会调用该组件的 <code>search()</code> 方法，并传入新的搜索框的值。</p>
<h3 id="6-7-3-AsyncPipe"><a href="#6-7-3-AsyncPipe" class="headerlink" title="6.7.3 AsyncPipe"></a>6.7.3 <code>AsyncPipe</code></h3><p><code>*ngFor</code> 会重复渲染这些英雄对象。注意，<code>*ngFor</code> 在一个名叫 <code>heroes$</code> 的列表上迭代，而不是 <code>heroes</code>。<code>$</code> 是一个约定，表示 <code>heroes$</code> 是一个 <code>Observable</code> 而不是数组。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes$ | async&quot;</span> &gt;</span><br></code></pre></div></td></tr></table></figure>



<p>由于 <code>*ngFor</code> 不能直接使用 <code>Observable</code>，所以要使用一个管道字符（<code>|</code>），后面紧跟着一个 <code>async</code>。这表示 Angular 的 <code>AsyncPipe</code> 管道，它会自动订阅 <code>Observable</code>，这样就不用在组件类中这么做了。</p>
<h3 id="6-7-4-修正-HeroSearchComponent-类"><a href="#6-7-4-修正-HeroSearchComponent-类" class="headerlink" title="6.7.4 修正 HeroSearchComponent 类"></a>6.7.4 修正 <code>HeroSearchComponent</code> 类</h3><p>修改所生成的 <code>HeroSearchComponent</code> 类及其元数据，代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123; Observable, Subject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123;<br>   debounceTime, distinctUntilChanged, switchMap<br> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123; Hero &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; HeroService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../hero.service&#x27;</span>;<br><br><span class="hljs-meta">@Component</span>(&#123;<br>  selector: <span class="hljs-string">&#x27;app-hero-search&#x27;</span>,<br>  templateUrl: <span class="hljs-string">&#x27;./hero-search.component.html&#x27;</span>,<br>  styleUrls: [ <span class="hljs-string">&#x27;./hero-search.component.css&#x27;</span> ]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroSearchComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;<br>  heroes$!: Observable&lt;Hero[]&gt;;<br>  <span class="hljs-keyword">private</span> searchTerms = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroService</span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Push a search term into the observable stream.</span><br>  search(term: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.searchTerms.next(term);<br>  &#125;<br><br>  ngOnInit(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.heroes$ = <span class="hljs-built_in">this</span>.searchTerms.pipe(<br>      <span class="hljs-comment">// wait 300ms after each keystroke before considering the term</span><br>      debounceTime(<span class="hljs-number">300</span>),<br><br>      <span class="hljs-comment">// ignore new term if same as previous term</span><br>      distinctUntilChanged(),<br><br>      <span class="hljs-comment">// switch to new search observable each time the term changes</span><br>      switchMap(<span class="hljs-function">(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">this</span>.heroService.searchHeroes(term)),<br>    );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>注意，<code>heroes$</code> 声明为一个 <code>Observable</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">heroes$!: Observable&lt;Hero[]&gt;;<br></code></pre></div></td></tr></table></figure>

<p>将会在 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt6#search-pipe"><code>ngOnInit()</code></a> 中设置它，在此之前，先仔细看看 <code>searchTerms</code> 的定义。</p>
<h3 id="6-7-5-RxJS-Subject-类型的-searchTerms"><a href="#6-7-5-RxJS-Subject-类型的-searchTerms" class="headerlink" title="6.7.5 RxJS Subject 类型的 searchTerms"></a>6.7.5 RxJS <code>Subject</code> 类型的 <code>searchTerms</code></h3><p><code>searchTerms</code> 属性是 RxJS 的 <code>Subject</code> 类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> searchTerms = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-built_in">string</span>&gt;();<br><br><span class="hljs-comment">// Push a search term into the observable stream.</span><br>search(term: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-built_in">this</span>.searchTerms.next(term);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Subject</code> 既是可观察对象的数据源，本身也是 <code>Observable</code>。可以像订阅任何 <code>Observable</code> 一样订阅 <code>Subject</code>。</p>
<p>还可以通过调用它的 <code>next(value)</code> 方法往 <code>Observable</code> 中推送一些值，就像 <code>search()</code> 方法中一样。</p>
<p>文本框的 <code>input</code> 事件的<em>事件绑定</em>会调用 <code>search()</code> 方法。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> #<span class="hljs-attr">searchBox</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search-box&quot;</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">&quot;search(searchBox.value)&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>每当用户在文本框中输入时，这个事件绑定就会使用文本框的值（搜索词）调用 <code>search()</code> 函数。<code>searchTerms</code> 变成了一个能发出搜索词的稳定的流。</p>
<h3 id="6-7-6-串联-RxJS-操作符"><a href="#6-7-6-串联-RxJS-操作符" class="headerlink" title="6.7.6 串联 RxJS 操作符"></a>6.7.6 串联 RxJS 操作符</h3><p>如果每当用户按键后就直接调用 <code>searchHeroes()</code> 将导致创建海量的 HTTP 请求，浪费服务器资源并干扰数据调度计划。</p>
<p>应该怎么做呢？<code>ngOnInit()</code> 往 <code>searchTerms</code> 这个可观察对象的处理管道中加入了一系列 RxJS 操作符，用以缩减对 <code>searchHeroes()</code> 的调用次数，并最终返回一个可及时给出英雄搜索结果的可观察对象（每次都是 <code>Hero[]</code>）。</p>
<p>代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-built_in">this</span>.heroes$ = <span class="hljs-built_in">this</span>.searchTerms.pipe(<br>  <span class="hljs-comment">// wait 300ms after each keystroke before considering the term</span><br>  debounceTime(<span class="hljs-number">300</span>),<br><br>  <span class="hljs-comment">// ignore new term if same as previous term</span><br>  distinctUntilChanged(),<br><br>  <span class="hljs-comment">// switch to new search observable each time the term changes</span><br>  switchMap(<span class="hljs-function">(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">this</span>.heroService.searchHeroes(term)),<br>);<br></code></pre></div></td></tr></table></figure>



<p>各个操作符的工作方式如下：</p>
<ul>
<li>在传出最终字符串之前，<code>debounceTime(300)</code> 将会等待，直到新增字符串的事件暂停了 300 毫秒。实际发起请求的间隔永远不会小于 300ms。</li>
<li><code>distinctUntilChanged()</code> 会确保只在过滤条件变化时才发送请求。</li>
<li><code>switchMap()</code> 会为每个从 <code>debounce()</code> 和 <code>distinctUntilChanged()</code> 中通过的搜索词调用搜索服务。它会取消并丢弃以前的搜索可观察对象，只保留最近的。</li>
</ul>
<p>借助 <a target="_blank" rel="noopener" href="http://www.learnrxjs.io/operators/transformation/switchmap.html">switchMap 操作符</a>，每个有效的按键事件都会触发一次 <code>HttpClient.get()</code> 方法调用。即使在每个请求之间都有至少 300ms 的间隔，仍然可能会同时存在多个尚未返回的 HTTP 请求。</p>
<p><code>switchMap()</code> 会记住原始的请求顺序，只会返回最近一次 HTTP 方法调用的结果。以前的那些请求都会被取消和舍弃。</p>
<p><strong>注意</strong>：<br>取消前一个 <code>searchHeroes()</code> 可观察对象并不会中止尚未完成的 HTTP 请求。那些不想要的结果只会在它们抵达应用代码之前被舍弃。</p>
<p>记住，组件类中并没有订阅 <code>heroes$</code> 这个可观察对象，而是由模板中的 <a target="_blank" rel="noopener" href="https://angular.cn/tutorial/toh-pt6#asyncpipe"><code>AsyncPipe</code></a> 完成的。</p>
<p>再次运行本应用。在这个 <em>仪表盘</em> 中，在搜索框中输入一些文字。如果输入的字符匹配上了任何现有英雄的名字，将会看到如下效果。</p>
<p><img src="../img/Angular-tour-of-heros/6-7-6.gif" srcset="/img/loading.gif" lazyload alt="6-7-6"></p>
<h2 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h2><ul>
<li>添加了在应用程序中使用 HTTP 的必备依赖</li>
<li>重构了 <code>HeroService</code>，以通过 web API 来加载英雄数据</li>
<li>扩展了 <code>HeroService</code> 来支持 <code>post()</code>、<code>put()</code> 和 <code>delete()</code> 方法</li>
<li>修改了组件，以允许用户添加、编辑和删除英雄</li>
<li>配置了一个内存 Web API</li>
<li>学会了如何使用“可观察对象”</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Angular%E9%A1%B9%E7%9B%AE/">Angular项目</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Angular/">Angular</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/19/drawPixel0519/">
                        <span class="hidden-mobile">Java绘图软件</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
